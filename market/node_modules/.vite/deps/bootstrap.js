import {
  require_jquery
} from "./chunk-UEPLLAIO.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-CF3WPAMV.js";

// node_modules/popper.js/dist/esm/popper.js
var popper_exports = {};
__export(popper_exports, {
  default: () => popper_default
});
function microtaskDebounce(fn) {
  var called = false;
  return function() {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function() {
      called = false;
      fn();
    });
  };
}
function taskDebounce(fn) {
  var scheduled = false;
  return function() {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function() {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
}
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  var window2 = element.ownerDocument.defaultView;
  var css = window2.getComputedStyle(element, null);
  return property ? css[property] : css;
}
function getParentNode(element) {
  if (element.nodeName === "HTML") {
    return element;
  }
  return element.parentNode || element.host;
}
function getScrollParent(element) {
  if (!element) {
    return document.body;
  }
  switch (element.nodeName) {
    case "HTML":
    case "BODY":
      return element.ownerDocument.body;
    case "#document":
      return element.body;
  }
  var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }
  return getScrollParent(getParentNode(element));
}
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }
  var noOffsetParent = isIE(10) ? document.body : null;
  var offsetParent = element.offsetParent || null;
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }
  var nodeName = offsetParent && offsetParent.nodeName;
  if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }
  if (["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
    return getOffsetParent(offsetParent);
  }
  return offsetParent;
}
function isOffsetContainer(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY") {
    return false;
  }
  return nodeName === "HTML" || getOffsetParent(element.firstElementChild) === element;
}
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }
  return node;
}
function findCommonOffsetParent(element1, element2) {
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;
  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }
    return getOffsetParent(commonAncestorContainer);
  }
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top";
  var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }
  return element[upperSide];
}
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var scrollTop = getScroll(element, "top");
  var scrollLeft = getScroll(element, "left");
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
function getBordersSize(styles, axis) {
  var sideA = axis === "x" ? "Left" : "Top";
  var sideB = sideA === "Left" ? "Right" : "Bottom";
  return parseFloat(styles["border" + sideA + "Width"]) + parseFloat(styles["border" + sideB + "Width"]);
}
function getSize(axis, body, html, computedStyle) {
  return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]) : 0);
}
function getWindowSizes(document2) {
  var body = document2.body;
  var html = document2.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize("Height", body, html, computedStyle),
    width: getSize("Width", body, html, computedStyle)
  };
}
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
function getBoundingClientRect(element) {
  var rect = {};
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, "top");
      var scrollLeft = getScroll(element, "left");
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {
  }
  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };
  var sizes = element.nodeName === "HTML" ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, "x");
    vertScrollbar -= getBordersSize(styles, "y");
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }
  return getClientRect(result);
}
function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isIE102 = isIE(10);
  var isHTML = parent.nodeName === "HTML";
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;
  if (!isIE102 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }
  if (isIE102 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== "BODY") {
    offsets = includeScroll(offsets, parent);
  }
  return offsets;
}
function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, "left") : 0;
  var offset2 = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width,
    height
  };
  return getClientRect(offset2);
}
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === "BODY" || nodeName === "HTML") {
    return false;
  }
  if (getStyleComputedProperty(element, "position") === "fixed") {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}
function getFixedPositionOffsetParent(element) {
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, "transform") === "none") {
    el = el.parentElement;
  }
  return el || document.documentElement;
}
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  if (boundariesElement === "viewport") {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    var boundariesNode = void 0;
    if (boundariesElement === "scrollParent") {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === "BODY") {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === "window") {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }
    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
    if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument), height = _getWindowSizes.height, width = _getWindowSizes.width;
      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      boundaries = offsets;
    }
  }
  padding = padding || 0;
  var isPaddingNumber = typeof padding === "number";
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}
function getArea(_ref) {
  var width = _ref.width, height = _ref.height;
  return width * height;
}
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
  if (placement.indexOf("auto") === -1) {
    return placement;
  }
  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function(key) {
    return _extends({
      key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function(a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function(_ref2) {
    var width = _ref2.width, height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split("-")[1];
  return computedPlacement + (variation ? "-" + variation : "");
}
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
function getOuterSizes(element) {
  var window2 = element.ownerDocument.defaultView;
  var styles = window2.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}
function getOppositePlacement(placement) {
  var hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split("-")[0];
  var popperRect = getOuterSizes(popper);
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };
  var isHoriz = ["right", "left"].indexOf(placement) !== -1;
  var mainSide = isHoriz ? "top" : "left";
  var secondarySide = isHoriz ? "left" : "top";
  var measurement = isHoriz ? "height" : "width";
  var secondaryMeasurement = !isHoriz ? "height" : "width";
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }
  return popperOffsets;
}
function find(arr, check) {
  if (Array.prototype.find) {
    return arr.find(check);
  }
  return arr.filter(check)[0];
}
function findIndex(arr, prop, value) {
  if (Array.prototype.findIndex) {
    return arr.findIndex(function(cur) {
      return cur[prop] === value;
    });
  }
  var match = find(arr, function(obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
function runModifiers(modifiers2, data, ends) {
  var modifiersToRun = ends === void 0 ? modifiers2 : modifiers2.slice(0, findIndex(modifiers2, "name", ends));
  modifiersToRun.forEach(function(modifier) {
    if (modifier["function"]) {
      console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
    }
    var fn = modifier["function"] || modifier.fn;
    if (modifier.enabled && isFunction(fn)) {
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}
function update() {
  if (this.state.isDestroyed) {
    return;
  }
  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed;
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
  data = runModifiers(this.modifiers, data);
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
function isModifierEnabled(modifiers2, modifierName) {
  return modifiers2.some(function(_ref) {
    var name = _ref.name, enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}
function getSupportedPropertyName(property) {
  var prefixes = [false, "ms", "Webkit", "Moz", "O"];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? "" + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== "undefined") {
      return toCheck;
    }
  }
  return null;
}
function destroy() {
  this.state.isDestroyed = true;
  if (isModifierEnabled(this.modifiers, "applyStyle")) {
    this.popper.removeAttribute("x-placement");
    this.popper.style.position = "";
    this.popper.style.top = "";
    this.popper.style.left = "";
    this.popper.style.right = "";
    this.popper.style.bottom = "";
    this.popper.style.willChange = "";
    this.popper.style[getSupportedPropertyName("transform")] = "";
  }
  this.disableEventListeners();
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}
function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === "BODY";
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });
  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}
function setupEventListeners(reference, options, state, updateBound) {
  state.updateBound = updateBound;
  getWindow(reference).addEventListener("resize", state.updateBound, { passive: true });
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
function removeEventListeners(reference, state) {
  getWindow(reference).removeEventListener("resize", state.updateBound);
  state.scrollParents.forEach(function(target) {
    target.removeEventListener("scroll", state.updateBound);
  });
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
function isNumeric(n) {
  return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
}
function setStyles(element, styles) {
  Object.keys(styles).forEach(function(prop) {
    var unit = "";
    if (["width", "height", "top", "right", "bottom", "left"].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = "px";
    }
    element.style[prop] = styles[prop] + unit;
  });
}
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function(prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
function applyStyle(data) {
  setStyles(data.instance.popper, data.styles);
  setAttributes(data.instance.popper, data.attributes);
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }
  return data;
}
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute("x-placement", placement);
  setStyles(popper, { position: options.positionFixed ? "fixed" : "absolute" });
  return options;
}
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var round = Math.round, floor = Math.floor;
  var noRound = function noRound2(v) {
    return v;
  };
  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ["left", "right"].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf("-") !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}
function computeStyle(data, options) {
  var x = options.x, y = options.y;
  var popper = data.offsets.popper;
  var legacyGpuAccelerationOption = find(data.instance.modifiers, function(modifier) {
    return modifier.name === "applyStyle";
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== void 0) {
    console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== void 0 ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);
  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === "bottom" ? "top" : "bottom";
  var sideB = y === "right" ? "left" : "right";
  var prefixedProperty = getSupportedPropertyName("transform");
  var left = void 0, top = void 0;
  if (sideA === "bottom") {
    if (offsetParent.nodeName === "HTML") {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === "right") {
    if (offsetParent.nodeName === "HTML") {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = "translate3d(" + left + "px, " + top + "px, 0)";
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = "transform";
  } else {
    var invertTop = sideA === "bottom" ? -1 : 1;
    var invertLeft = sideB === "right" ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ", " + sideB;
  }
  var attributes = {
    "x-placement": data.placement
  };
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
function isModifierRequired(modifiers2, requestingName, requestedName) {
  var requesting = find(modifiers2, function(_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers2.some(function(modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });
  if (!isRequired) {
    var _requesting = "`" + requestingName + "`";
    var requested = "`" + requestedName + "`";
    console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
  }
  return isRequired;
}
function arrow(data, options) {
  var _data$offsets$arrow;
  if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
    return data;
  }
  var arrowElement = options.element;
  if (typeof arrowElement === "string") {
    arrowElement = data.instance.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return data;
    }
  } else {
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn("WARNING: `arrow.element` must be child of its popper element!");
      return data;
    }
  }
  var placement = data.placement.split("-")[0];
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var isVertical = ["left", "right"].indexOf(placement) !== -1;
  var len = isVertical ? "height" : "width";
  var sideCapitalized = isVertical ? "Top" : "Left";
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? "left" : "top";
  var opSide = isVertical ? "bottom" : "right";
  var arrowElementSize = getOuterSizes(arrowElement)[len];
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css["margin" + sideCapitalized]);
  var popperBorderSide = parseFloat(css["border" + sideCapitalized + "Width"]);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
  return data;
}
function getOppositeVariation(variation) {
  if (variation === "end") {
    return "start";
  } else if (variation === "start") {
    return "end";
  }
  return variation;
}
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}
function flip(data, options) {
  if (isModifierEnabled(data.instance.modifiers, "inner")) {
    return data;
  }
  if (data.flipped && data.placement === data.originalPlacement) {
    return data;
  }
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split("-")[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split("-")[1] || "";
  var flipOrder = [];
  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }
  flipOrder.forEach(function(step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }
    placement = data.placement.split("-")[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;
    var floor = Math.floor;
    var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
    var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === "start" && overflowsRight || isVertical && variation === "end" && overflowsLeft || !isVertical && variation === "start" && overflowsBottom || !isVertical && variation === "end" && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;
    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      data.flipped = true;
      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }
      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }
      data.placement = placement + (variation ? "-" + variation : "");
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, "flip");
    }
  });
  return data;
}
function keepTogether(data) {
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var placement = data.placement.split("-")[0];
  var floor = Math.floor;
  var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
  var side = isVertical ? "right" : "bottom";
  var opSide = isVertical ? "left" : "top";
  var measurement = isVertical ? "width" : "height";
  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }
  return data;
}
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];
  if (!value) {
    return str;
  }
  if (unit.indexOf("%") === 0) {
    var element = void 0;
    switch (unit) {
      case "%p":
        element = popperOffsets;
        break;
      case "%":
      case "%r":
      default:
        element = referenceOffsets;
    }
    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === "vh" || unit === "vw") {
    var size = void 0;
    if (unit === "vh") {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    return value;
  }
}
function parseOffset(offset2, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];
  var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;
  var fragments = offset2.split(/(\+|\-)/).map(function(frag) {
    return frag.trim();
  });
  var divider = fragments.indexOf(find(fragments, function(frag) {
    return frag.search(/,|\s/) !== -1;
  }));
  if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
    console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
  }
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
  ops = ops.map(function(op, index) {
    var measurement = (index === 1 ? !useHeight : useHeight) ? "height" : "width";
    var mergeWithPrevious = false;
    return op.reduce(function(a, b) {
      if (a[a.length - 1] === "" && ["+", "-"].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, []).map(function(str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });
  ops.forEach(function(op, index) {
    op.forEach(function(frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1);
      }
    });
  });
  return offsets;
}
function offset(data, _ref) {
  var offset2 = _ref.offset;
  var placement = data.placement, _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var basePlacement = placement.split("-")[0];
  var offsets = void 0;
  if (isNumeric(+offset2)) {
    offsets = [+offset2, 0];
  } else {
    offsets = parseOffset(offset2, popper, reference, basePlacement);
  }
  if (basePlacement === "left") {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === "right") {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === "top") {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === "bottom") {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }
  data.popper = popper;
  return data;
}
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }
  var transformProp = getSupportedPropertyName("transform");
  var popperStyles = data.instance.popper.style;
  var top = popperStyles.top, left = popperStyles.left, transform = popperStyles[transformProp];
  popperStyles.top = "";
  popperStyles.left = "";
  popperStyles[transformProp] = "";
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === "right" ? "left" : "top";
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function(placement) {
    var side = ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
    popper = _extends({}, popper, check[side](placement));
  });
  data.offsets.popper = popper;
  return data;
}
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split("-")[0];
  var shiftvariation = placement.split("-")[1];
  if (shiftvariation) {
    var _data$offsets = data.offsets, reference = _data$offsets.reference, popper = _data$offsets.popper;
    var isVertical = ["bottom", "top"].indexOf(basePlacement) !== -1;
    var side = isVertical ? "left" : "top";
    var measurement = isVertical ? "width" : "height";
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }
  return data;
}
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
    return data;
  }
  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function(modifier) {
    return modifier.name === "preventOverflow";
  }).boundaries;
  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    if (data.hide === true) {
      return data;
    }
    data.hide = true;
    data.attributes["x-out-of-boundaries"] = "";
  } else {
    if (data.hide === false) {
      return data;
    }
    data.hide = false;
    data.attributes["x-out-of-boundaries"] = false;
  }
  return data;
}
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split("-")[0];
  var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
  var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;
  var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;
  popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);
  return data;
}
var isBrowser, timeoutDuration, supportsMicroTasks, debounce, isIE11, isIE10, classCallCheck, createClass, defineProperty, _extends, isFirefox, placements, validPlacements, BEHAVIORS, modifiers, Defaults, Popper, popper_default;
var init_popper = __esm({
  "node_modules/popper.js/dist/esm/popper.js"() {
    isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined";
    timeoutDuration = function() {
      var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
      for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
        if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
          return 1;
        }
      }
      return 0;
    }();
    supportsMicroTasks = isBrowser && window.Promise;
    debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
    isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
    isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
    classCallCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };
    createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    defineProperty = function(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    };
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
    placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
    validPlacements = placements.slice(3);
    BEHAVIORS = {
      FLIP: "flip",
      CLOCKWISE: "clockwise",
      COUNTERCLOCKWISE: "counterclockwise"
    };
    modifiers = {
      /**
       * Modifier used to shift the popper on the start or end of its reference
       * element.<br />
       * It will read the variation of the `placement` property.<br />
       * It can be one either `-end` or `-start`.
       * @memberof modifiers
       * @inner
       */
      shift: {
        /** @prop {number} order=100 - Index used to define the order of execution */
        order: 100,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: shift
      },
      /**
       * The `offset` modifier can shift your popper on both its axis.
       *
       * It accepts the following units:
       * - `px` or unit-less, interpreted as pixels
       * - `%` or `%r`, percentage relative to the length of the reference element
       * - `%p`, percentage relative to the length of the popper element
       * - `vw`, CSS viewport width unit
       * - `vh`, CSS viewport height unit
       *
       * For length is intended the main axis relative to the placement of the popper.<br />
       * This means that if the placement is `top` or `bottom`, the length will be the
       * `width`. In case of `left` or `right`, it will be the `height`.
       *
       * You can provide a single value (as `Number` or `String`), or a pair of values
       * as `String` divided by a comma or one (or more) white spaces.<br />
       * The latter is a deprecated method because it leads to confusion and will be
       * removed in v2.<br />
       * Additionally, it accepts additions and subtractions between different units.
       * Note that multiplications and divisions aren't supported.
       *
       * Valid examples are:
       * ```
       * 10
       * '10%'
       * '10, 10'
       * '10%, 10'
       * '10 + 10%'
       * '10 - 5vh + 3%'
       * '-10px + 5vh, 5px - 6%'
       * ```
       * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
       * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
       * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
       *
       * @memberof modifiers
       * @inner
       */
      offset: {
        /** @prop {number} order=200 - Index used to define the order of execution */
        order: 200,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: offset,
        /** @prop {Number|String} offset=0
         * The offset value as described in the modifier description
         */
        offset: 0
      },
      /**
       * Modifier used to prevent the popper from being positioned outside the boundary.
       *
       * A scenario exists where the reference itself is not within the boundaries.<br />
       * We can say it has "escaped the boundaries" — or just "escaped".<br />
       * In this case we need to decide whether the popper should either:
       *
       * - detach from the reference and remain "trapped" in the boundaries, or
       * - if it should ignore the boundary and "escape with its reference"
       *
       * When `escapeWithReference` is set to`true` and reference is completely
       * outside its boundaries, the popper will overflow (or completely leave)
       * the boundaries in order to remain attached to the edge of the reference.
       *
       * @memberof modifiers
       * @inner
       */
      preventOverflow: {
        /** @prop {number} order=300 - Index used to define the order of execution */
        order: 300,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: preventOverflow,
        /**
         * @prop {Array} [priority=['left','right','top','bottom']]
         * Popper will try to prevent overflow following these priorities by default,
         * then, it could overflow on the left and on top of the `boundariesElement`
         */
        priority: ["left", "right", "top", "bottom"],
        /**
         * @prop {number} padding=5
         * Amount of pixel used to define a minimum distance between the boundaries
         * and the popper. This makes sure the popper always has a little padding
         * between the edges of its container
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='scrollParent'
         * Boundaries used by the modifier. Can be `scrollParent`, `window`,
         * `viewport` or any DOM element.
         */
        boundariesElement: "scrollParent"
      },
      /**
       * Modifier used to make sure the reference and its popper stay near each other
       * without leaving any gap between the two. Especially useful when the arrow is
       * enabled and you want to ensure that it points to its reference element.
       * It cares only about the first axis. You can still have poppers with margin
       * between the popper and its reference element.
       * @memberof modifiers
       * @inner
       */
      keepTogether: {
        /** @prop {number} order=400 - Index used to define the order of execution */
        order: 400,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: keepTogether
      },
      /**
       * This modifier is used to move the `arrowElement` of the popper to make
       * sure it is positioned between the reference element and its popper element.
       * It will read the outer size of the `arrowElement` node to detect how many
       * pixels of conjunction are needed.
       *
       * It has no effect if no `arrowElement` is provided.
       * @memberof modifiers
       * @inner
       */
      arrow: {
        /** @prop {number} order=500 - Index used to define the order of execution */
        order: 500,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: arrow,
        /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
        element: "[x-arrow]"
      },
      /**
       * Modifier used to flip the popper's placement when it starts to overlap its
       * reference element.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       *
       * **NOTE:** this modifier will interrupt the current update cycle and will
       * restart it if it detects the need to flip the placement.
       * @memberof modifiers
       * @inner
       */
      flip: {
        /** @prop {number} order=600 - Index used to define the order of execution */
        order: 600,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: flip,
        /**
         * @prop {String|Array} behavior='flip'
         * The behavior used to change the popper's placement. It can be one of
         * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
         * placements (with optional variations)
         */
        behavior: "flip",
        /**
         * @prop {number} padding=5
         * The popper will flip if it hits the edges of the `boundariesElement`
         */
        padding: 5,
        /**
         * @prop {String|HTMLElement} boundariesElement='viewport'
         * The element which will define the boundaries of the popper position.
         * The popper will never be placed outside of the defined boundaries
         * (except if `keepTogether` is enabled)
         */
        boundariesElement: "viewport",
        /**
         * @prop {Boolean} flipVariations=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the reference element overlaps its boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariations: false,
        /**
         * @prop {Boolean} flipVariationsByContent=false
         * The popper will switch placement variation between `-start` and `-end` when
         * the popper element overlaps its reference boundaries.
         *
         * The original placement should have a set variation.
         */
        flipVariationsByContent: false
      },
      /**
       * Modifier used to make the popper flow toward the inner of the reference element.
       * By default, when this modifier is disabled, the popper will be placed outside
       * the reference element.
       * @memberof modifiers
       * @inner
       */
      inner: {
        /** @prop {number} order=700 - Index used to define the order of execution */
        order: 700,
        /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
        enabled: false,
        /** @prop {ModifierFn} */
        fn: inner
      },
      /**
       * Modifier used to hide the popper when its reference element is outside of the
       * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
       * be used to hide with a CSS selector the popper when its reference is
       * out of boundaries.
       *
       * Requires the `preventOverflow` modifier before it in order to work.
       * @memberof modifiers
       * @inner
       */
      hide: {
        /** @prop {number} order=800 - Index used to define the order of execution */
        order: 800,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: hide
      },
      /**
       * Computes the style that will be applied to the popper element to gets
       * properly positioned.
       *
       * Note that this modifier will not touch the DOM, it just prepares the styles
       * so that `applyStyle` modifier can apply it. This separation is useful
       * in case you need to replace `applyStyle` with a custom implementation.
       *
       * This modifier has `850` as `order` value to maintain backward compatibility
       * with previous versions of Popper.js. Expect the modifiers ordering method
       * to change in future major versions of the library.
       *
       * @memberof modifiers
       * @inner
       */
      computeStyle: {
        /** @prop {number} order=850 - Index used to define the order of execution */
        order: 850,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: computeStyle,
        /**
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: true,
        /**
         * @prop {string} [x='bottom']
         * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
         * Change this if your popper should grow in a direction different from `bottom`
         */
        x: "bottom",
        /**
         * @prop {string} [x='left']
         * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
         * Change this if your popper should grow in a direction different from `right`
         */
        y: "right"
      },
      /**
       * Applies the computed styles to the popper element.
       *
       * All the DOM manipulations are limited to this modifier. This is useful in case
       * you want to integrate Popper.js inside a framework or view library and you
       * want to delegate all the DOM manipulations to it.
       *
       * Note that if you disable this modifier, you must make sure the popper element
       * has its position set to `absolute` before Popper.js can do its work!
       *
       * Just disable this modifier and define your own to achieve the desired effect.
       *
       * @memberof modifiers
       * @inner
       */
      applyStyle: {
        /** @prop {number} order=900 - Index used to define the order of execution */
        order: 900,
        /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
        enabled: true,
        /** @prop {ModifierFn} */
        fn: applyStyle,
        /** @prop {Function} */
        onLoad: applyStyleOnLoad,
        /**
         * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
         * @prop {Boolean} gpuAcceleration=true
         * If true, it uses the CSS 3D transformation to position the popper.
         * Otherwise, it will use the `top` and `left` properties
         */
        gpuAcceleration: void 0
      }
    };
    Defaults = {
      /**
       * Popper's placement.
       * @prop {Popper.placements} placement='bottom'
       */
      placement: "bottom",
      /**
       * Set this to true if you want popper to position it self in 'fixed' mode
       * @prop {Boolean} positionFixed=false
       */
      positionFixed: false,
      /**
       * Whether events (resize, scroll) are initially enabled.
       * @prop {Boolean} eventsEnabled=true
       */
      eventsEnabled: true,
      /**
       * Set to true if you want to automatically remove the popper when
       * you call the `destroy` method.
       * @prop {Boolean} removeOnDestroy=false
       */
      removeOnDestroy: false,
      /**
       * Callback called when the popper is created.<br />
       * By default, it is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onCreate}
       */
      onCreate: function onCreate() {
      },
      /**
       * Callback called when the popper is updated. This callback is not called
       * on the initialization/creation of the popper, but only on subsequent
       * updates.<br />
       * By default, it is set to no-op.<br />
       * Access Popper.js instance with `data.instance`.
       * @prop {onUpdate}
       */
      onUpdate: function onUpdate() {
      },
      /**
       * List of modifiers used to modify the offsets before they are applied to the popper.
       * They provide most of the functionalities of Popper.js.
       * @prop {modifiers}
       */
      modifiers
    };
    Popper = function() {
      function Popper2(reference, popper) {
        var _this = this;
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        classCallCheck(this, Popper2);
        this.scheduleUpdate = function() {
          return requestAnimationFrame(_this.update);
        };
        this.update = debounce(this.update.bind(this));
        this.options = _extends({}, Popper2.Defaults, options);
        this.state = {
          isDestroyed: false,
          isCreated: false,
          scrollParents: []
        };
        this.reference = reference && reference.jquery ? reference[0] : reference;
        this.popper = popper && popper.jquery ? popper[0] : popper;
        this.options.modifiers = {};
        Object.keys(_extends({}, Popper2.Defaults.modifiers, options.modifiers)).forEach(function(name) {
          _this.options.modifiers[name] = _extends({}, Popper2.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
        });
        this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
          return _extends({
            name
          }, _this.options.modifiers[name]);
        }).sort(function(a, b) {
          return a.order - b.order;
        });
        this.modifiers.forEach(function(modifierOptions) {
          if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
            modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
          }
        });
        this.update();
        var eventsEnabled = this.options.eventsEnabled;
        if (eventsEnabled) {
          this.enableEventListeners();
        }
        this.state.eventsEnabled = eventsEnabled;
      }
      createClass(Popper2, [{
        key: "update",
        value: function update$$1() {
          return update.call(this);
        }
      }, {
        key: "destroy",
        value: function destroy$$1() {
          return destroy.call(this);
        }
      }, {
        key: "enableEventListeners",
        value: function enableEventListeners$$1() {
          return enableEventListeners.call(this);
        }
      }, {
        key: "disableEventListeners",
        value: function disableEventListeners$$1() {
          return disableEventListeners.call(this);
        }
        /**
         * Schedules an update. It will run on the next UI update available.
         * @method scheduleUpdate
         * @memberof Popper
         */
        /**
         * Collection of utilities useful when writing custom modifiers.
         * Starting from version 1.7, this method is available only if you
         * include `popper-utils.js` before `popper.js`.
         *
         * **DEPRECATION**: This way to access PopperUtils is deprecated
         * and will be removed in v2! Use the PopperUtils module directly instead.
         * Due to the high instability of the methods contained in Utils, we can't
         * guarantee them to follow semver. Use them at your own risk!
         * @static
         * @private
         * @type {Object}
         * @deprecated since version 1.8
         * @member Utils
         * @memberof Popper
         */
      }]);
      return Popper2;
    }();
    Popper.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
    Popper.placements = placements;
    Popper.Defaults = Defaults;
    popper_default = Popper;
  }
});

// node_modules/bootstrap/dist/js/bootstrap.js
var require_bootstrap = __commonJS({
  "node_modules/bootstrap/dist/js/bootstrap.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_jquery(), (init_popper(), __toCommonJS(popper_exports))) : typeof define === "function" && define.amd ? define(["exports", "jquery", "popper.js"], factory) : factory(global2.bootstrap = {}, global2.jQuery, global2.Popper);
    })(exports, function(exports2, $, Popper2) {
      "use strict";
      $ = $ && $.hasOwnProperty("default") ? $["default"] : $;
      Popper2 = Popper2 && Popper2.hasOwnProperty("default") ? Popper2["default"] : Popper2;
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          var ownKeys = Object.keys(source);
          if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
              return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
          }
          ownKeys.forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        }
        return target;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var Util = function($$$1) {
        var TRANSITION_END = "transitionend";
        var MAX_UID = 1e6;
        var MILLISECONDS_MULTIPLIER = 1e3;
        function toType(obj) {
          return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
        }
        function getSpecialTransitionEndEvent() {
          return {
            bindType: TRANSITION_END,
            delegateType: TRANSITION_END,
            handle: function handle(event) {
              if ($$$1(event.target).is(this)) {
                return event.handleObj.handler.apply(this, arguments);
              }
              return void 0;
            }
          };
        }
        function transitionEndEmulator(duration) {
          var _this = this;
          var called = false;
          $$$1(this).one(Util2.TRANSITION_END, function() {
            called = true;
          });
          setTimeout(function() {
            if (!called) {
              Util2.triggerTransitionEnd(_this);
            }
          }, duration);
          return this;
        }
        function setTransitionEndSupport() {
          $$$1.fn.emulateTransitionEnd = transitionEndEmulator;
          $$$1.event.special[Util2.TRANSITION_END] = getSpecialTransitionEndEvent();
        }
        var Util2 = {
          TRANSITION_END: "bsTransitionEnd",
          getUID: function getUID(prefix) {
            do {
              prefix += ~~(Math.random() * MAX_UID);
            } while (document.getElementById(prefix));
            return prefix;
          },
          getSelectorFromElement: function getSelectorFromElement(element) {
            var selector = element.getAttribute("data-target");
            if (!selector || selector === "#") {
              selector = element.getAttribute("href") || "";
            }
            try {
              var $selector = $$$1(document).find(selector);
              return $selector.length > 0 ? selector : null;
            } catch (err) {
              return null;
            }
          },
          getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
            if (!element) {
              return 0;
            }
            var transitionDuration = $$$1(element).css("transition-duration");
            var floatTransitionDuration = parseFloat(transitionDuration);
            if (!floatTransitionDuration) {
              return 0;
            }
            transitionDuration = transitionDuration.split(",")[0];
            return parseFloat(transitionDuration) * MILLISECONDS_MULTIPLIER;
          },
          reflow: function reflow(element) {
            return element.offsetHeight;
          },
          triggerTransitionEnd: function triggerTransitionEnd(element) {
            $$$1(element).trigger(TRANSITION_END);
          },
          // TODO: Remove in v5
          supportsTransitionEnd: function supportsTransitionEnd() {
            return Boolean(TRANSITION_END);
          },
          isElement: function isElement(obj) {
            return (obj[0] || obj).nodeType;
          },
          typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
            for (var property in configTypes) {
              if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
                var expectedTypes = configTypes[property];
                var value = config[property];
                var valueType = value && Util2.isElement(value) ? "element" : toType(value);
                if (!new RegExp(expectedTypes).test(valueType)) {
                  throw new Error(componentName.toUpperCase() + ": " + ('Option "' + property + '" provided type "' + valueType + '" ') + ('but expected type "' + expectedTypes + '".'));
                }
              }
            }
          }
        };
        setTransitionEndSupport();
        return Util2;
      }($);
      var Alert = function($$$1) {
        var NAME = "alert";
        var VERSION = "4.1.1";
        var DATA_KEY = "bs.alert";
        var EVENT_KEY = "." + DATA_KEY;
        var DATA_API_KEY = ".data-api";
        var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
        var Selector = {
          DISMISS: '[data-dismiss="alert"]'
        };
        var Event = {
          CLOSE: "close" + EVENT_KEY,
          CLOSED: "closed" + EVENT_KEY,
          CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
          ALERT: "alert",
          FADE: "fade",
          SHOW: "show"
          /**
           * ------------------------------------------------------------------------
           * Class Definition
           * ------------------------------------------------------------------------
           */
        };
        var Alert2 = function() {
          function Alert3(element) {
            this._element = element;
          }
          var _proto = Alert3.prototype;
          _proto.close = function close(element) {
            var rootElement = this._element;
            if (element) {
              rootElement = this._getRootElement(element);
            }
            var customEvent = this._triggerCloseEvent(rootElement);
            if (customEvent.isDefaultPrevented()) {
              return;
            }
            this._removeElement(rootElement);
          };
          _proto.dispose = function dispose() {
            $$$1.removeData(this._element, DATA_KEY);
            this._element = null;
          };
          _proto._getRootElement = function _getRootElement(element) {
            var selector = Util.getSelectorFromElement(element);
            var parent = false;
            if (selector) {
              parent = $$$1(selector)[0];
            }
            if (!parent) {
              parent = $$$1(element).closest("." + ClassName.ALERT)[0];
            }
            return parent;
          };
          _proto._triggerCloseEvent = function _triggerCloseEvent(element) {
            var closeEvent = $$$1.Event(Event.CLOSE);
            $$$1(element).trigger(closeEvent);
            return closeEvent;
          };
          _proto._removeElement = function _removeElement(element) {
            var _this = this;
            $$$1(element).removeClass(ClassName.SHOW);
            if (!$$$1(element).hasClass(ClassName.FADE)) {
              this._destroyElement(element);
              return;
            }
            var transitionDuration = Util.getTransitionDurationFromElement(element);
            $$$1(element).one(Util.TRANSITION_END, function(event) {
              return _this._destroyElement(element, event);
            }).emulateTransitionEnd(transitionDuration);
          };
          _proto._destroyElement = function _destroyElement(element) {
            $$$1(element).detach().trigger(Event.CLOSED).remove();
          };
          Alert3._jQueryInterface = function _jQueryInterface(config) {
            return this.each(function() {
              var $element = $$$1(this);
              var data = $element.data(DATA_KEY);
              if (!data) {
                data = new Alert3(this);
                $element.data(DATA_KEY, data);
              }
              if (config === "close") {
                data[config](this);
              }
            });
          };
          Alert3._handleDismiss = function _handleDismiss(alertInstance) {
            return function(event) {
              if (event) {
                event.preventDefault();
              }
              alertInstance.close(this);
            };
          };
          _createClass(Alert3, null, [{
            key: "VERSION",
            get: function get() {
              return VERSION;
            }
          }]);
          return Alert3;
        }();
        $$$1(document).on(Event.CLICK_DATA_API, Selector.DISMISS, Alert2._handleDismiss(new Alert2()));
        $$$1.fn[NAME] = Alert2._jQueryInterface;
        $$$1.fn[NAME].Constructor = Alert2;
        $$$1.fn[NAME].noConflict = function() {
          $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
          return Alert2._jQueryInterface;
        };
        return Alert2;
      }($);
      var Button = function($$$1) {
        var NAME = "button";
        var VERSION = "4.1.1";
        var DATA_KEY = "bs.button";
        var EVENT_KEY = "." + DATA_KEY;
        var DATA_API_KEY = ".data-api";
        var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
        var ClassName = {
          ACTIVE: "active",
          BUTTON: "btn",
          FOCUS: "focus"
        };
        var Selector = {
          DATA_TOGGLE_CARROT: '[data-toggle^="button"]',
          DATA_TOGGLE: '[data-toggle="buttons"]',
          INPUT: "input",
          ACTIVE: ".active",
          BUTTON: ".btn"
        };
        var Event = {
          CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY,
          FOCUS_BLUR_DATA_API: "focus" + EVENT_KEY + DATA_API_KEY + " " + ("blur" + EVENT_KEY + DATA_API_KEY)
          /**
           * ------------------------------------------------------------------------
           * Class Definition
           * ------------------------------------------------------------------------
           */
        };
        var Button2 = function() {
          function Button3(element) {
            this._element = element;
          }
          var _proto = Button3.prototype;
          _proto.toggle = function toggle() {
            var triggerChangeEvent = true;
            var addAriaPressed = true;
            var rootElement = $$$1(this._element).closest(Selector.DATA_TOGGLE)[0];
            if (rootElement) {
              var input = $$$1(this._element).find(Selector.INPUT)[0];
              if (input) {
                if (input.type === "radio") {
                  if (input.checked && $$$1(this._element).hasClass(ClassName.ACTIVE)) {
                    triggerChangeEvent = false;
                  } else {
                    var activeElement = $$$1(rootElement).find(Selector.ACTIVE)[0];
                    if (activeElement) {
                      $$$1(activeElement).removeClass(ClassName.ACTIVE);
                    }
                  }
                }
                if (triggerChangeEvent) {
                  if (input.hasAttribute("disabled") || rootElement.hasAttribute("disabled") || input.classList.contains("disabled") || rootElement.classList.contains("disabled")) {
                    return;
                  }
                  input.checked = !$$$1(this._element).hasClass(ClassName.ACTIVE);
                  $$$1(input).trigger("change");
                }
                input.focus();
                addAriaPressed = false;
              }
            }
            if (addAriaPressed) {
              this._element.setAttribute("aria-pressed", !$$$1(this._element).hasClass(ClassName.ACTIVE));
            }
            if (triggerChangeEvent) {
              $$$1(this._element).toggleClass(ClassName.ACTIVE);
            }
          };
          _proto.dispose = function dispose() {
            $$$1.removeData(this._element, DATA_KEY);
            this._element = null;
          };
          Button3._jQueryInterface = function _jQueryInterface(config) {
            return this.each(function() {
              var data = $$$1(this).data(DATA_KEY);
              if (!data) {
                data = new Button3(this);
                $$$1(this).data(DATA_KEY, data);
              }
              if (config === "toggle") {
                data[config]();
              }
            });
          };
          _createClass(Button3, null, [{
            key: "VERSION",
            get: function get() {
              return VERSION;
            }
          }]);
          return Button3;
        }();
        $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE_CARROT, function(event) {
          event.preventDefault();
          var button = event.target;
          if (!$$$1(button).hasClass(ClassName.BUTTON)) {
            button = $$$1(button).closest(Selector.BUTTON);
          }
          Button2._jQueryInterface.call($$$1(button), "toggle");
        }).on(Event.FOCUS_BLUR_DATA_API, Selector.DATA_TOGGLE_CARROT, function(event) {
          var button = $$$1(event.target).closest(Selector.BUTTON)[0];
          $$$1(button).toggleClass(ClassName.FOCUS, /^focus(in)?$/.test(event.type));
        });
        $$$1.fn[NAME] = Button2._jQueryInterface;
        $$$1.fn[NAME].Constructor = Button2;
        $$$1.fn[NAME].noConflict = function() {
          $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
          return Button2._jQueryInterface;
        };
        return Button2;
      }($);
      var Carousel = function($$$1) {
        var NAME = "carousel";
        var VERSION = "4.1.1";
        var DATA_KEY = "bs.carousel";
        var EVENT_KEY = "." + DATA_KEY;
        var DATA_API_KEY = ".data-api";
        var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
        var ARROW_LEFT_KEYCODE = 37;
        var ARROW_RIGHT_KEYCODE = 39;
        var TOUCHEVENT_COMPAT_WAIT = 500;
        var Default = {
          interval: 5e3,
          keyboard: true,
          slide: false,
          pause: "hover",
          wrap: true
        };
        var DefaultType = {
          interval: "(number|boolean)",
          keyboard: "boolean",
          slide: "(boolean|string)",
          pause: "(string|boolean)",
          wrap: "boolean"
        };
        var Direction = {
          NEXT: "next",
          PREV: "prev",
          LEFT: "left",
          RIGHT: "right"
        };
        var Event = {
          SLIDE: "slide" + EVENT_KEY,
          SLID: "slid" + EVENT_KEY,
          KEYDOWN: "keydown" + EVENT_KEY,
          MOUSEENTER: "mouseenter" + EVENT_KEY,
          MOUSELEAVE: "mouseleave" + EVENT_KEY,
          TOUCHEND: "touchend" + EVENT_KEY,
          LOAD_DATA_API: "load" + EVENT_KEY + DATA_API_KEY,
          CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
          CAROUSEL: "carousel",
          ACTIVE: "active",
          SLIDE: "slide",
          RIGHT: "carousel-item-right",
          LEFT: "carousel-item-left",
          NEXT: "carousel-item-next",
          PREV: "carousel-item-prev",
          ITEM: "carousel-item"
        };
        var Selector = {
          ACTIVE: ".active",
          ACTIVE_ITEM: ".active.carousel-item",
          ITEM: ".carousel-item",
          NEXT_PREV: ".carousel-item-next, .carousel-item-prev",
          INDICATORS: ".carousel-indicators",
          DATA_SLIDE: "[data-slide], [data-slide-to]",
          DATA_RIDE: '[data-ride="carousel"]'
          /**
           * ------------------------------------------------------------------------
           * Class Definition
           * ------------------------------------------------------------------------
           */
        };
        var Carousel2 = function() {
          function Carousel3(element, config) {
            this._items = null;
            this._interval = null;
            this._activeElement = null;
            this._isPaused = false;
            this._isSliding = false;
            this.touchTimeout = null;
            this._config = this._getConfig(config);
            this._element = $$$1(element)[0];
            this._indicatorsElement = $$$1(this._element).find(Selector.INDICATORS)[0];
            this._addEventListeners();
          }
          var _proto = Carousel3.prototype;
          _proto.next = function next() {
            if (!this._isSliding) {
              this._slide(Direction.NEXT);
            }
          };
          _proto.nextWhenVisible = function nextWhenVisible() {
            if (!document.hidden && $$$1(this._element).is(":visible") && $$$1(this._element).css("visibility") !== "hidden") {
              this.next();
            }
          };
          _proto.prev = function prev() {
            if (!this._isSliding) {
              this._slide(Direction.PREV);
            }
          };
          _proto.pause = function pause(event) {
            if (!event) {
              this._isPaused = true;
            }
            if ($$$1(this._element).find(Selector.NEXT_PREV)[0]) {
              Util.triggerTransitionEnd(this._element);
              this.cycle(true);
            }
            clearInterval(this._interval);
            this._interval = null;
          };
          _proto.cycle = function cycle(event) {
            if (!event) {
              this._isPaused = false;
            }
            if (this._interval) {
              clearInterval(this._interval);
              this._interval = null;
            }
            if (this._config.interval && !this._isPaused) {
              this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
            }
          };
          _proto.to = function to(index) {
            var _this = this;
            this._activeElement = $$$1(this._element).find(Selector.ACTIVE_ITEM)[0];
            var activeIndex = this._getItemIndex(this._activeElement);
            if (index > this._items.length - 1 || index < 0) {
              return;
            }
            if (this._isSliding) {
              $$$1(this._element).one(Event.SLID, function() {
                return _this.to(index);
              });
              return;
            }
            if (activeIndex === index) {
              this.pause();
              this.cycle();
              return;
            }
            var direction = index > activeIndex ? Direction.NEXT : Direction.PREV;
            this._slide(direction, this._items[index]);
          };
          _proto.dispose = function dispose() {
            $$$1(this._element).off(EVENT_KEY);
            $$$1.removeData(this._element, DATA_KEY);
            this._items = null;
            this._config = null;
            this._element = null;
            this._interval = null;
            this._isPaused = null;
            this._isSliding = null;
            this._activeElement = null;
            this._indicatorsElement = null;
          };
          _proto._getConfig = function _getConfig(config) {
            config = _objectSpread({}, Default, config);
            Util.typeCheckConfig(NAME, config, DefaultType);
            return config;
          };
          _proto._addEventListeners = function _addEventListeners() {
            var _this2 = this;
            if (this._config.keyboard) {
              $$$1(this._element).on(Event.KEYDOWN, function(event) {
                return _this2._keydown(event);
              });
            }
            if (this._config.pause === "hover") {
              $$$1(this._element).on(Event.MOUSEENTER, function(event) {
                return _this2.pause(event);
              }).on(Event.MOUSELEAVE, function(event) {
                return _this2.cycle(event);
              });
              if ("ontouchstart" in document.documentElement) {
                $$$1(this._element).on(Event.TOUCHEND, function() {
                  _this2.pause();
                  if (_this2.touchTimeout) {
                    clearTimeout(_this2.touchTimeout);
                  }
                  _this2.touchTimeout = setTimeout(function(event) {
                    return _this2.cycle(event);
                  }, TOUCHEVENT_COMPAT_WAIT + _this2._config.interval);
                });
              }
            }
          };
          _proto._keydown = function _keydown(event) {
            if (/input|textarea/i.test(event.target.tagName)) {
              return;
            }
            switch (event.which) {
              case ARROW_LEFT_KEYCODE:
                event.preventDefault();
                this.prev();
                break;
              case ARROW_RIGHT_KEYCODE:
                event.preventDefault();
                this.next();
                break;
              default:
            }
          };
          _proto._getItemIndex = function _getItemIndex(element) {
            this._items = $$$1.makeArray($$$1(element).parent().find(Selector.ITEM));
            return this._items.indexOf(element);
          };
          _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {
            var isNextDirection = direction === Direction.NEXT;
            var isPrevDirection = direction === Direction.PREV;
            var activeIndex = this._getItemIndex(activeElement);
            var lastItemIndex = this._items.length - 1;
            var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;
            if (isGoingToWrap && !this._config.wrap) {
              return activeElement;
            }
            var delta = direction === Direction.PREV ? -1 : 1;
            var itemIndex = (activeIndex + delta) % this._items.length;
            return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];
          };
          _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {
            var targetIndex = this._getItemIndex(relatedTarget);
            var fromIndex = this._getItemIndex($$$1(this._element).find(Selector.ACTIVE_ITEM)[0]);
            var slideEvent = $$$1.Event(Event.SLIDE, {
              relatedTarget,
              direction: eventDirectionName,
              from: fromIndex,
              to: targetIndex
            });
            $$$1(this._element).trigger(slideEvent);
            return slideEvent;
          };
          _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {
            if (this._indicatorsElement) {
              $$$1(this._indicatorsElement).find(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
              var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];
              if (nextIndicator) {
                $$$1(nextIndicator).addClass(ClassName.ACTIVE);
              }
            }
          };
          _proto._slide = function _slide(direction, element) {
            var _this3 = this;
            var activeElement = $$$1(this._element).find(Selector.ACTIVE_ITEM)[0];
            var activeElementIndex = this._getItemIndex(activeElement);
            var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);
            var nextElementIndex = this._getItemIndex(nextElement);
            var isCycling = Boolean(this._interval);
            var directionalClassName;
            var orderClassName;
            var eventDirectionName;
            if (direction === Direction.NEXT) {
              directionalClassName = ClassName.LEFT;
              orderClassName = ClassName.NEXT;
              eventDirectionName = Direction.LEFT;
            } else {
              directionalClassName = ClassName.RIGHT;
              orderClassName = ClassName.PREV;
              eventDirectionName = Direction.RIGHT;
            }
            if (nextElement && $$$1(nextElement).hasClass(ClassName.ACTIVE)) {
              this._isSliding = false;
              return;
            }
            var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);
            if (slideEvent.isDefaultPrevented()) {
              return;
            }
            if (!activeElement || !nextElement) {
              return;
            }
            this._isSliding = true;
            if (isCycling) {
              this.pause();
            }
            this._setActiveIndicatorElement(nextElement);
            var slidEvent = $$$1.Event(Event.SLID, {
              relatedTarget: nextElement,
              direction: eventDirectionName,
              from: activeElementIndex,
              to: nextElementIndex
            });
            if ($$$1(this._element).hasClass(ClassName.SLIDE)) {
              $$$1(nextElement).addClass(orderClassName);
              Util.reflow(nextElement);
              $$$1(activeElement).addClass(directionalClassName);
              $$$1(nextElement).addClass(directionalClassName);
              var transitionDuration = Util.getTransitionDurationFromElement(activeElement);
              $$$1(activeElement).one(Util.TRANSITION_END, function() {
                $$$1(nextElement).removeClass(directionalClassName + " " + orderClassName).addClass(ClassName.ACTIVE);
                $$$1(activeElement).removeClass(ClassName.ACTIVE + " " + orderClassName + " " + directionalClassName);
                _this3._isSliding = false;
                setTimeout(function() {
                  return $$$1(_this3._element).trigger(slidEvent);
                }, 0);
              }).emulateTransitionEnd(transitionDuration);
            } else {
              $$$1(activeElement).removeClass(ClassName.ACTIVE);
              $$$1(nextElement).addClass(ClassName.ACTIVE);
              this._isSliding = false;
              $$$1(this._element).trigger(slidEvent);
            }
            if (isCycling) {
              this.cycle();
            }
          };
          Carousel3._jQueryInterface = function _jQueryInterface(config) {
            return this.each(function() {
              var data = $$$1(this).data(DATA_KEY);
              var _config = _objectSpread({}, Default, $$$1(this).data());
              if (typeof config === "object") {
                _config = _objectSpread({}, _config, config);
              }
              var action = typeof config === "string" ? config : _config.slide;
              if (!data) {
                data = new Carousel3(this, _config);
                $$$1(this).data(DATA_KEY, data);
              }
              if (typeof config === "number") {
                data.to(config);
              } else if (typeof action === "string") {
                if (typeof data[action] === "undefined") {
                  throw new TypeError('No method named "' + action + '"');
                }
                data[action]();
              } else if (_config.interval) {
                data.pause();
                data.cycle();
              }
            });
          };
          Carousel3._dataApiClickHandler = function _dataApiClickHandler(event) {
            var selector = Util.getSelectorFromElement(this);
            if (!selector) {
              return;
            }
            var target = $$$1(selector)[0];
            if (!target || !$$$1(target).hasClass(ClassName.CAROUSEL)) {
              return;
            }
            var config = _objectSpread({}, $$$1(target).data(), $$$1(this).data());
            var slideIndex = this.getAttribute("data-slide-to");
            if (slideIndex) {
              config.interval = false;
            }
            Carousel3._jQueryInterface.call($$$1(target), config);
            if (slideIndex) {
              $$$1(target).data(DATA_KEY).to(slideIndex);
            }
            event.preventDefault();
          };
          _createClass(Carousel3, null, [{
            key: "VERSION",
            get: function get() {
              return VERSION;
            }
          }, {
            key: "Default",
            get: function get() {
              return Default;
            }
          }]);
          return Carousel3;
        }();
        $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_SLIDE, Carousel2._dataApiClickHandler);
        $$$1(window).on(Event.LOAD_DATA_API, function() {
          $$$1(Selector.DATA_RIDE).each(function() {
            var $carousel = $$$1(this);
            Carousel2._jQueryInterface.call($carousel, $carousel.data());
          });
        });
        $$$1.fn[NAME] = Carousel2._jQueryInterface;
        $$$1.fn[NAME].Constructor = Carousel2;
        $$$1.fn[NAME].noConflict = function() {
          $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
          return Carousel2._jQueryInterface;
        };
        return Carousel2;
      }($);
      var Collapse = function($$$1) {
        var NAME = "collapse";
        var VERSION = "4.1.1";
        var DATA_KEY = "bs.collapse";
        var EVENT_KEY = "." + DATA_KEY;
        var DATA_API_KEY = ".data-api";
        var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
        var Default = {
          toggle: true,
          parent: ""
        };
        var DefaultType = {
          toggle: "boolean",
          parent: "(string|element)"
        };
        var Event = {
          SHOW: "show" + EVENT_KEY,
          SHOWN: "shown" + EVENT_KEY,
          HIDE: "hide" + EVENT_KEY,
          HIDDEN: "hidden" + EVENT_KEY,
          CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
          SHOW: "show",
          COLLAPSE: "collapse",
          COLLAPSING: "collapsing",
          COLLAPSED: "collapsed"
        };
        var Dimension = {
          WIDTH: "width",
          HEIGHT: "height"
        };
        var Selector = {
          ACTIVES: ".show, .collapsing",
          DATA_TOGGLE: '[data-toggle="collapse"]'
          /**
           * ------------------------------------------------------------------------
           * Class Definition
           * ------------------------------------------------------------------------
           */
        };
        var Collapse2 = function() {
          function Collapse3(element, config) {
            this._isTransitioning = false;
            this._element = element;
            this._config = this._getConfig(config);
            this._triggerArray = $$$1.makeArray($$$1('[data-toggle="collapse"][href="#' + element.id + '"],' + ('[data-toggle="collapse"][data-target="#' + element.id + '"]')));
            var tabToggles = $$$1(Selector.DATA_TOGGLE);
            for (var i = 0; i < tabToggles.length; i++) {
              var elem = tabToggles[i];
              var selector = Util.getSelectorFromElement(elem);
              if (selector !== null && $$$1(selector).filter(element).length > 0) {
                this._selector = selector;
                this._triggerArray.push(elem);
              }
            }
            this._parent = this._config.parent ? this._getParent() : null;
            if (!this._config.parent) {
              this._addAriaAndCollapsedClass(this._element, this._triggerArray);
            }
            if (this._config.toggle) {
              this.toggle();
            }
          }
          var _proto = Collapse3.prototype;
          _proto.toggle = function toggle() {
            if ($$$1(this._element).hasClass(ClassName.SHOW)) {
              this.hide();
            } else {
              this.show();
            }
          };
          _proto.show = function show() {
            var _this = this;
            if (this._isTransitioning || $$$1(this._element).hasClass(ClassName.SHOW)) {
              return;
            }
            var actives;
            var activesData;
            if (this._parent) {
              actives = $$$1.makeArray($$$1(this._parent).find(Selector.ACTIVES).filter('[data-parent="' + this._config.parent + '"]'));
              if (actives.length === 0) {
                actives = null;
              }
            }
            if (actives) {
              activesData = $$$1(actives).not(this._selector).data(DATA_KEY);
              if (activesData && activesData._isTransitioning) {
                return;
              }
            }
            var startEvent = $$$1.Event(Event.SHOW);
            $$$1(this._element).trigger(startEvent);
            if (startEvent.isDefaultPrevented()) {
              return;
            }
            if (actives) {
              Collapse3._jQueryInterface.call($$$1(actives).not(this._selector), "hide");
              if (!activesData) {
                $$$1(actives).data(DATA_KEY, null);
              }
            }
            var dimension = this._getDimension();
            $$$1(this._element).removeClass(ClassName.COLLAPSE).addClass(ClassName.COLLAPSING);
            this._element.style[dimension] = 0;
            if (this._triggerArray.length > 0) {
              $$$1(this._triggerArray).removeClass(ClassName.COLLAPSED).attr("aria-expanded", true);
            }
            this.setTransitioning(true);
            var complete = function complete2() {
              $$$1(_this._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).addClass(ClassName.SHOW);
              _this._element.style[dimension] = "";
              _this.setTransitioning(false);
              $$$1(_this._element).trigger(Event.SHOWN);
            };
            var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
            var scrollSize = "scroll" + capitalizedDimension;
            var transitionDuration = Util.getTransitionDurationFromElement(this._element);
            $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
            this._element.style[dimension] = this._element[scrollSize] + "px";
          };
          _proto.hide = function hide2() {
            var _this2 = this;
            if (this._isTransitioning || !$$$1(this._element).hasClass(ClassName.SHOW)) {
              return;
            }
            var startEvent = $$$1.Event(Event.HIDE);
            $$$1(this._element).trigger(startEvent);
            if (startEvent.isDefaultPrevented()) {
              return;
            }
            var dimension = this._getDimension();
            this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + "px";
            Util.reflow(this._element);
            $$$1(this._element).addClass(ClassName.COLLAPSING).removeClass(ClassName.COLLAPSE).removeClass(ClassName.SHOW);
            if (this._triggerArray.length > 0) {
              for (var i = 0; i < this._triggerArray.length; i++) {
                var trigger = this._triggerArray[i];
                var selector = Util.getSelectorFromElement(trigger);
                if (selector !== null) {
                  var $elem = $$$1(selector);
                  if (!$elem.hasClass(ClassName.SHOW)) {
                    $$$1(trigger).addClass(ClassName.COLLAPSED).attr("aria-expanded", false);
                  }
                }
              }
            }
            this.setTransitioning(true);
            var complete = function complete2() {
              _this2.setTransitioning(false);
              $$$1(_this2._element).removeClass(ClassName.COLLAPSING).addClass(ClassName.COLLAPSE).trigger(Event.HIDDEN);
            };
            this._element.style[dimension] = "";
            var transitionDuration = Util.getTransitionDurationFromElement(this._element);
            $$$1(this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
          };
          _proto.setTransitioning = function setTransitioning(isTransitioning) {
            this._isTransitioning = isTransitioning;
          };
          _proto.dispose = function dispose() {
            $$$1.removeData(this._element, DATA_KEY);
            this._config = null;
            this._parent = null;
            this._element = null;
            this._triggerArray = null;
            this._isTransitioning = null;
          };
          _proto._getConfig = function _getConfig(config) {
            config = _objectSpread({}, Default, config);
            config.toggle = Boolean(config.toggle);
            Util.typeCheckConfig(NAME, config, DefaultType);
            return config;
          };
          _proto._getDimension = function _getDimension() {
            var hasWidth = $$$1(this._element).hasClass(Dimension.WIDTH);
            return hasWidth ? Dimension.WIDTH : Dimension.HEIGHT;
          };
          _proto._getParent = function _getParent() {
            var _this3 = this;
            var parent = null;
            if (Util.isElement(this._config.parent)) {
              parent = this._config.parent;
              if (typeof this._config.parent.jquery !== "undefined") {
                parent = this._config.parent[0];
              }
            } else {
              parent = $$$1(this._config.parent)[0];
            }
            var selector = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]';
            $$$1(parent).find(selector).each(function(i, element) {
              _this3._addAriaAndCollapsedClass(Collapse3._getTargetFromElement(element), [element]);
            });
            return parent;
          };
          _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {
            if (element) {
              var isOpen = $$$1(element).hasClass(ClassName.SHOW);
              if (triggerArray.length > 0) {
                $$$1(triggerArray).toggleClass(ClassName.COLLAPSED, !isOpen).attr("aria-expanded", isOpen);
              }
            }
          };
          Collapse3._getTargetFromElement = function _getTargetFromElement(element) {
            var selector = Util.getSelectorFromElement(element);
            return selector ? $$$1(selector)[0] : null;
          };
          Collapse3._jQueryInterface = function _jQueryInterface(config) {
            return this.each(function() {
              var $this = $$$1(this);
              var data = $this.data(DATA_KEY);
              var _config = _objectSpread({}, Default, $this.data(), typeof config === "object" && config ? config : {});
              if (!data && _config.toggle && /show|hide/.test(config)) {
                _config.toggle = false;
              }
              if (!data) {
                data = new Collapse3(this, _config);
                $this.data(DATA_KEY, data);
              }
              if (typeof config === "string") {
                if (typeof data[config] === "undefined") {
                  throw new TypeError('No method named "' + config + '"');
                }
                data[config]();
              }
            });
          };
          _createClass(Collapse3, null, [{
            key: "VERSION",
            get: function get() {
              return VERSION;
            }
          }, {
            key: "Default",
            get: function get() {
              return Default;
            }
          }]);
          return Collapse3;
        }();
        $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function(event) {
          if (event.currentTarget.tagName === "A") {
            event.preventDefault();
          }
          var $trigger = $$$1(this);
          var selector = Util.getSelectorFromElement(this);
          $$$1(selector).each(function() {
            var $target = $$$1(this);
            var data = $target.data(DATA_KEY);
            var config = data ? "toggle" : $trigger.data();
            Collapse2._jQueryInterface.call($target, config);
          });
        });
        $$$1.fn[NAME] = Collapse2._jQueryInterface;
        $$$1.fn[NAME].Constructor = Collapse2;
        $$$1.fn[NAME].noConflict = function() {
          $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
          return Collapse2._jQueryInterface;
        };
        return Collapse2;
      }($);
      var Dropdown = function($$$1) {
        var NAME = "dropdown";
        var VERSION = "4.1.1";
        var DATA_KEY = "bs.dropdown";
        var EVENT_KEY = "." + DATA_KEY;
        var DATA_API_KEY = ".data-api";
        var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
        var ESCAPE_KEYCODE = 27;
        var SPACE_KEYCODE = 32;
        var TAB_KEYCODE = 9;
        var ARROW_UP_KEYCODE = 38;
        var ARROW_DOWN_KEYCODE = 40;
        var RIGHT_MOUSE_BUTTON_WHICH = 3;
        var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + "|" + ARROW_DOWN_KEYCODE + "|" + ESCAPE_KEYCODE);
        var Event = {
          HIDE: "hide" + EVENT_KEY,
          HIDDEN: "hidden" + EVENT_KEY,
          SHOW: "show" + EVENT_KEY,
          SHOWN: "shown" + EVENT_KEY,
          CLICK: "click" + EVENT_KEY,
          CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY,
          KEYDOWN_DATA_API: "keydown" + EVENT_KEY + DATA_API_KEY,
          KEYUP_DATA_API: "keyup" + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
          DISABLED: "disabled",
          SHOW: "show",
          DROPUP: "dropup",
          DROPRIGHT: "dropright",
          DROPLEFT: "dropleft",
          MENURIGHT: "dropdown-menu-right",
          MENULEFT: "dropdown-menu-left",
          POSITION_STATIC: "position-static"
        };
        var Selector = {
          DATA_TOGGLE: '[data-toggle="dropdown"]',
          FORM_CHILD: ".dropdown form",
          MENU: ".dropdown-menu",
          NAVBAR_NAV: ".navbar-nav",
          VISIBLE_ITEMS: ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)"
        };
        var AttachmentMap = {
          TOP: "top-start",
          TOPEND: "top-end",
          BOTTOM: "bottom-start",
          BOTTOMEND: "bottom-end",
          RIGHT: "right-start",
          RIGHTEND: "right-end",
          LEFT: "left-start",
          LEFTEND: "left-end"
        };
        var Default = {
          offset: 0,
          flip: true,
          boundary: "scrollParent",
          reference: "toggle",
          display: "dynamic"
        };
        var DefaultType = {
          offset: "(number|string|function)",
          flip: "boolean",
          boundary: "(string|element)",
          reference: "(string|element)",
          display: "string"
          /**
           * ------------------------------------------------------------------------
           * Class Definition
           * ------------------------------------------------------------------------
           */
        };
        var Dropdown2 = function() {
          function Dropdown3(element, config) {
            this._element = element;
            this._popper = null;
            this._config = this._getConfig(config);
            this._menu = this._getMenuElement();
            this._inNavbar = this._detectNavbar();
            this._addEventListeners();
          }
          var _proto = Dropdown3.prototype;
          _proto.toggle = function toggle() {
            if (this._element.disabled || $$$1(this._element).hasClass(ClassName.DISABLED)) {
              return;
            }
            var parent = Dropdown3._getParentFromElement(this._element);
            var isActive = $$$1(this._menu).hasClass(ClassName.SHOW);
            Dropdown3._clearMenus();
            if (isActive) {
              return;
            }
            var relatedTarget = {
              relatedTarget: this._element
            };
            var showEvent = $$$1.Event(Event.SHOW, relatedTarget);
            $$$1(parent).trigger(showEvent);
            if (showEvent.isDefaultPrevented()) {
              return;
            }
            if (!this._inNavbar) {
              if (typeof Popper2 === "undefined") {
                throw new TypeError("Bootstrap dropdown require Popper.js (https://popper.js.org)");
              }
              var referenceElement = this._element;
              if (this._config.reference === "parent") {
                referenceElement = parent;
              } else if (Util.isElement(this._config.reference)) {
                referenceElement = this._config.reference;
                if (typeof this._config.reference.jquery !== "undefined") {
                  referenceElement = this._config.reference[0];
                }
              }
              if (this._config.boundary !== "scrollParent") {
                $$$1(parent).addClass(ClassName.POSITION_STATIC);
              }
              this._popper = new Popper2(referenceElement, this._menu, this._getPopperConfig());
            }
            if ("ontouchstart" in document.documentElement && $$$1(parent).closest(Selector.NAVBAR_NAV).length === 0) {
              $$$1(document.body).children().on("mouseover", null, $$$1.noop);
            }
            this._element.focus();
            this._element.setAttribute("aria-expanded", true);
            $$$1(this._menu).toggleClass(ClassName.SHOW);
            $$$1(parent).toggleClass(ClassName.SHOW).trigger($$$1.Event(Event.SHOWN, relatedTarget));
          };
          _proto.dispose = function dispose() {
            $$$1.removeData(this._element, DATA_KEY);
            $$$1(this._element).off(EVENT_KEY);
            this._element = null;
            this._menu = null;
            if (this._popper !== null) {
              this._popper.destroy();
              this._popper = null;
            }
          };
          _proto.update = function update2() {
            this._inNavbar = this._detectNavbar();
            if (this._popper !== null) {
              this._popper.scheduleUpdate();
            }
          };
          _proto._addEventListeners = function _addEventListeners() {
            var _this = this;
            $$$1(this._element).on(Event.CLICK, function(event) {
              event.preventDefault();
              event.stopPropagation();
              _this.toggle();
            });
          };
          _proto._getConfig = function _getConfig(config) {
            config = _objectSpread({}, this.constructor.Default, $$$1(this._element).data(), config);
            Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
            return config;
          };
          _proto._getMenuElement = function _getMenuElement() {
            if (!this._menu) {
              var parent = Dropdown3._getParentFromElement(this._element);
              this._menu = $$$1(parent).find(Selector.MENU)[0];
            }
            return this._menu;
          };
          _proto._getPlacement = function _getPlacement() {
            var $parentDropdown = $$$1(this._element).parent();
            var placement = AttachmentMap.BOTTOM;
            if ($parentDropdown.hasClass(ClassName.DROPUP)) {
              placement = AttachmentMap.TOP;
              if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
                placement = AttachmentMap.TOPEND;
              }
            } else if ($parentDropdown.hasClass(ClassName.DROPRIGHT)) {
              placement = AttachmentMap.RIGHT;
            } else if ($parentDropdown.hasClass(ClassName.DROPLEFT)) {
              placement = AttachmentMap.LEFT;
            } else if ($$$1(this._menu).hasClass(ClassName.MENURIGHT)) {
              placement = AttachmentMap.BOTTOMEND;
            }
            return placement;
          };
          _proto._detectNavbar = function _detectNavbar() {
            return $$$1(this._element).closest(".navbar").length > 0;
          };
          _proto._getPopperConfig = function _getPopperConfig() {
            var _this2 = this;
            var offsetConf = {};
            if (typeof this._config.offset === "function") {
              offsetConf.fn = function(data) {
                data.offsets = _objectSpread({}, data.offsets, _this2._config.offset(data.offsets) || {});
                return data;
              };
            } else {
              offsetConf.offset = this._config.offset;
            }
            var popperConfig = {
              placement: this._getPlacement(),
              modifiers: {
                offset: offsetConf,
                flip: {
                  enabled: this._config.flip
                },
                preventOverflow: {
                  boundariesElement: this._config.boundary
                }
              }
              // Disable Popper.js if we have a static display
            };
            if (this._config.display === "static") {
              popperConfig.modifiers.applyStyle = {
                enabled: false
              };
            }
            return popperConfig;
          };
          Dropdown3._jQueryInterface = function _jQueryInterface(config) {
            return this.each(function() {
              var data = $$$1(this).data(DATA_KEY);
              var _config = typeof config === "object" ? config : null;
              if (!data) {
                data = new Dropdown3(this, _config);
                $$$1(this).data(DATA_KEY, data);
              }
              if (typeof config === "string") {
                if (typeof data[config] === "undefined") {
                  throw new TypeError('No method named "' + config + '"');
                }
                data[config]();
              }
            });
          };
          Dropdown3._clearMenus = function _clearMenus(event) {
            if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === "keyup" && event.which !== TAB_KEYCODE)) {
              return;
            }
            var toggles = $$$1.makeArray($$$1(Selector.DATA_TOGGLE));
            for (var i = 0; i < toggles.length; i++) {
              var parent = Dropdown3._getParentFromElement(toggles[i]);
              var context = $$$1(toggles[i]).data(DATA_KEY);
              var relatedTarget = {
                relatedTarget: toggles[i]
              };
              if (!context) {
                continue;
              }
              var dropdownMenu = context._menu;
              if (!$$$1(parent).hasClass(ClassName.SHOW)) {
                continue;
              }
              if (event && (event.type === "click" && /input|textarea/i.test(event.target.tagName) || event.type === "keyup" && event.which === TAB_KEYCODE) && $$$1.contains(parent, event.target)) {
                continue;
              }
              var hideEvent = $$$1.Event(Event.HIDE, relatedTarget);
              $$$1(parent).trigger(hideEvent);
              if (hideEvent.isDefaultPrevented()) {
                continue;
              }
              if ("ontouchstart" in document.documentElement) {
                $$$1(document.body).children().off("mouseover", null, $$$1.noop);
              }
              toggles[i].setAttribute("aria-expanded", "false");
              $$$1(dropdownMenu).removeClass(ClassName.SHOW);
              $$$1(parent).removeClass(ClassName.SHOW).trigger($$$1.Event(Event.HIDDEN, relatedTarget));
            }
          };
          Dropdown3._getParentFromElement = function _getParentFromElement(element) {
            var parent;
            var selector = Util.getSelectorFromElement(element);
            if (selector) {
              parent = $$$1(selector)[0];
            }
            return parent || element.parentNode;
          };
          Dropdown3._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {
            if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $$$1(event.target).closest(Selector.MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {
              return;
            }
            event.preventDefault();
            event.stopPropagation();
            if (this.disabled || $$$1(this).hasClass(ClassName.DISABLED)) {
              return;
            }
            var parent = Dropdown3._getParentFromElement(this);
            var isActive = $$$1(parent).hasClass(ClassName.SHOW);
            if (!isActive && (event.which !== ESCAPE_KEYCODE || event.which !== SPACE_KEYCODE) || isActive && (event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE)) {
              if (event.which === ESCAPE_KEYCODE) {
                var toggle = $$$1(parent).find(Selector.DATA_TOGGLE)[0];
                $$$1(toggle).trigger("focus");
              }
              $$$1(this).trigger("click");
              return;
            }
            var items = $$$1(parent).find(Selector.VISIBLE_ITEMS).get();
            if (items.length === 0) {
              return;
            }
            var index = items.indexOf(event.target);
            if (event.which === ARROW_UP_KEYCODE && index > 0) {
              index--;
            }
            if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {
              index++;
            }
            if (index < 0) {
              index = 0;
            }
            items[index].focus();
          };
          _createClass(Dropdown3, null, [{
            key: "VERSION",
            get: function get() {
              return VERSION;
            }
          }, {
            key: "Default",
            get: function get() {
              return Default;
            }
          }, {
            key: "DefaultType",
            get: function get() {
              return DefaultType;
            }
          }]);
          return Dropdown3;
        }();
        $$$1(document).on(Event.KEYDOWN_DATA_API, Selector.DATA_TOGGLE, Dropdown2._dataApiKeydownHandler).on(Event.KEYDOWN_DATA_API, Selector.MENU, Dropdown2._dataApiKeydownHandler).on(Event.CLICK_DATA_API + " " + Event.KEYUP_DATA_API, Dropdown2._clearMenus).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function(event) {
          event.preventDefault();
          event.stopPropagation();
          Dropdown2._jQueryInterface.call($$$1(this), "toggle");
        }).on(Event.CLICK_DATA_API, Selector.FORM_CHILD, function(e) {
          e.stopPropagation();
        });
        $$$1.fn[NAME] = Dropdown2._jQueryInterface;
        $$$1.fn[NAME].Constructor = Dropdown2;
        $$$1.fn[NAME].noConflict = function() {
          $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
          return Dropdown2._jQueryInterface;
        };
        return Dropdown2;
      }($, Popper2);
      var Modal = function($$$1) {
        var NAME = "modal";
        var VERSION = "4.1.1";
        var DATA_KEY = "bs.modal";
        var EVENT_KEY = "." + DATA_KEY;
        var DATA_API_KEY = ".data-api";
        var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
        var ESCAPE_KEYCODE = 27;
        var Default = {
          backdrop: true,
          keyboard: true,
          focus: true,
          show: true
        };
        var DefaultType = {
          backdrop: "(boolean|string)",
          keyboard: "boolean",
          focus: "boolean",
          show: "boolean"
        };
        var Event = {
          HIDE: "hide" + EVENT_KEY,
          HIDDEN: "hidden" + EVENT_KEY,
          SHOW: "show" + EVENT_KEY,
          SHOWN: "shown" + EVENT_KEY,
          FOCUSIN: "focusin" + EVENT_KEY,
          RESIZE: "resize" + EVENT_KEY,
          CLICK_DISMISS: "click.dismiss" + EVENT_KEY,
          KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY,
          MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY,
          MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY,
          CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
          SCROLLBAR_MEASURER: "modal-scrollbar-measure",
          BACKDROP: "modal-backdrop",
          OPEN: "modal-open",
          FADE: "fade",
          SHOW: "show"
        };
        var Selector = {
          DIALOG: ".modal-dialog",
          DATA_TOGGLE: '[data-toggle="modal"]',
          DATA_DISMISS: '[data-dismiss="modal"]',
          FIXED_CONTENT: ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
          STICKY_CONTENT: ".sticky-top",
          NAVBAR_TOGGLER: ".navbar-toggler"
          /**
           * ------------------------------------------------------------------------
           * Class Definition
           * ------------------------------------------------------------------------
           */
        };
        var Modal2 = function() {
          function Modal3(element, config) {
            this._config = this._getConfig(config);
            this._element = element;
            this._dialog = $$$1(element).find(Selector.DIALOG)[0];
            this._backdrop = null;
            this._isShown = false;
            this._isBodyOverflowing = false;
            this._ignoreBackdropClick = false;
            this._scrollbarWidth = 0;
          }
          var _proto = Modal3.prototype;
          _proto.toggle = function toggle(relatedTarget) {
            return this._isShown ? this.hide() : this.show(relatedTarget);
          };
          _proto.show = function show(relatedTarget) {
            var _this = this;
            if (this._isTransitioning || this._isShown) {
              return;
            }
            if ($$$1(this._element).hasClass(ClassName.FADE)) {
              this._isTransitioning = true;
            }
            var showEvent = $$$1.Event(Event.SHOW, {
              relatedTarget
            });
            $$$1(this._element).trigger(showEvent);
            if (this._isShown || showEvent.isDefaultPrevented()) {
              return;
            }
            this._isShown = true;
            this._checkScrollbar();
            this._setScrollbar();
            this._adjustDialog();
            $$$1(document.body).addClass(ClassName.OPEN);
            this._setEscapeEvent();
            this._setResizeEvent();
            $$$1(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function(event) {
              return _this.hide(event);
            });
            $$$1(this._dialog).on(Event.MOUSEDOWN_DISMISS, function() {
              $$$1(_this._element).one(Event.MOUSEUP_DISMISS, function(event) {
                if ($$$1(event.target).is(_this._element)) {
                  _this._ignoreBackdropClick = true;
                }
              });
            });
            this._showBackdrop(function() {
              return _this._showElement(relatedTarget);
            });
          };
          _proto.hide = function hide2(event) {
            var _this2 = this;
            if (event) {
              event.preventDefault();
            }
            if (this._isTransitioning || !this._isShown) {
              return;
            }
            var hideEvent = $$$1.Event(Event.HIDE);
            $$$1(this._element).trigger(hideEvent);
            if (!this._isShown || hideEvent.isDefaultPrevented()) {
              return;
            }
            this._isShown = false;
            var transition = $$$1(this._element).hasClass(ClassName.FADE);
            if (transition) {
              this._isTransitioning = true;
            }
            this._setEscapeEvent();
            this._setResizeEvent();
            $$$1(document).off(Event.FOCUSIN);
            $$$1(this._element).removeClass(ClassName.SHOW);
            $$$1(this._element).off(Event.CLICK_DISMISS);
            $$$1(this._dialog).off(Event.MOUSEDOWN_DISMISS);
            if (transition) {
              var transitionDuration = Util.getTransitionDurationFromElement(this._element);
              $$$1(this._element).one(Util.TRANSITION_END, function(event2) {
                return _this2._hideModal(event2);
              }).emulateTransitionEnd(transitionDuration);
            } else {
              this._hideModal();
            }
          };
          _proto.dispose = function dispose() {
            $$$1.removeData(this._element, DATA_KEY);
            $$$1(window, document, this._element, this._backdrop).off(EVENT_KEY);
            this._config = null;
            this._element = null;
            this._dialog = null;
            this._backdrop = null;
            this._isShown = null;
            this._isBodyOverflowing = null;
            this._ignoreBackdropClick = null;
            this._scrollbarWidth = null;
          };
          _proto.handleUpdate = function handleUpdate() {
            this._adjustDialog();
          };
          _proto._getConfig = function _getConfig(config) {
            config = _objectSpread({}, Default, config);
            Util.typeCheckConfig(NAME, config, DefaultType);
            return config;
          };
          _proto._showElement = function _showElement(relatedTarget) {
            var _this3 = this;
            var transition = $$$1(this._element).hasClass(ClassName.FADE);
            if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
              document.body.appendChild(this._element);
            }
            this._element.style.display = "block";
            this._element.removeAttribute("aria-hidden");
            this._element.scrollTop = 0;
            if (transition) {
              Util.reflow(this._element);
            }
            $$$1(this._element).addClass(ClassName.SHOW);
            if (this._config.focus) {
              this._enforceFocus();
            }
            var shownEvent = $$$1.Event(Event.SHOWN, {
              relatedTarget
            });
            var transitionComplete = function transitionComplete2() {
              if (_this3._config.focus) {
                _this3._element.focus();
              }
              _this3._isTransitioning = false;
              $$$1(_this3._element).trigger(shownEvent);
            };
            if (transition) {
              var transitionDuration = Util.getTransitionDurationFromElement(this._element);
              $$$1(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
            } else {
              transitionComplete();
            }
          };
          _proto._enforceFocus = function _enforceFocus() {
            var _this4 = this;
            $$$1(document).off(Event.FOCUSIN).on(Event.FOCUSIN, function(event) {
              if (document !== event.target && _this4._element !== event.target && $$$1(_this4._element).has(event.target).length === 0) {
                _this4._element.focus();
              }
            });
          };
          _proto._setEscapeEvent = function _setEscapeEvent() {
            var _this5 = this;
            if (this._isShown && this._config.keyboard) {
              $$$1(this._element).on(Event.KEYDOWN_DISMISS, function(event) {
                if (event.which === ESCAPE_KEYCODE) {
                  event.preventDefault();
                  _this5.hide();
                }
              });
            } else if (!this._isShown) {
              $$$1(this._element).off(Event.KEYDOWN_DISMISS);
            }
          };
          _proto._setResizeEvent = function _setResizeEvent() {
            var _this6 = this;
            if (this._isShown) {
              $$$1(window).on(Event.RESIZE, function(event) {
                return _this6.handleUpdate(event);
              });
            } else {
              $$$1(window).off(Event.RESIZE);
            }
          };
          _proto._hideModal = function _hideModal() {
            var _this7 = this;
            this._element.style.display = "none";
            this._element.setAttribute("aria-hidden", true);
            this._isTransitioning = false;
            this._showBackdrop(function() {
              $$$1(document.body).removeClass(ClassName.OPEN);
              _this7._resetAdjustments();
              _this7._resetScrollbar();
              $$$1(_this7._element).trigger(Event.HIDDEN);
            });
          };
          _proto._removeBackdrop = function _removeBackdrop() {
            if (this._backdrop) {
              $$$1(this._backdrop).remove();
              this._backdrop = null;
            }
          };
          _proto._showBackdrop = function _showBackdrop(callback) {
            var _this8 = this;
            var animate = $$$1(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : "";
            if (this._isShown && this._config.backdrop) {
              this._backdrop = document.createElement("div");
              this._backdrop.className = ClassName.BACKDROP;
              if (animate) {
                $$$1(this._backdrop).addClass(animate);
              }
              $$$1(this._backdrop).appendTo(document.body);
              $$$1(this._element).on(Event.CLICK_DISMISS, function(event) {
                if (_this8._ignoreBackdropClick) {
                  _this8._ignoreBackdropClick = false;
                  return;
                }
                if (event.target !== event.currentTarget) {
                  return;
                }
                if (_this8._config.backdrop === "static") {
                  _this8._element.focus();
                } else {
                  _this8.hide();
                }
              });
              if (animate) {
                Util.reflow(this._backdrop);
              }
              $$$1(this._backdrop).addClass(ClassName.SHOW);
              if (!callback) {
                return;
              }
              if (!animate) {
                callback();
                return;
              }
              var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
              $$$1(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
            } else if (!this._isShown && this._backdrop) {
              $$$1(this._backdrop).removeClass(ClassName.SHOW);
              var callbackRemove = function callbackRemove2() {
                _this8._removeBackdrop();
                if (callback) {
                  callback();
                }
              };
              if ($$$1(this._element).hasClass(ClassName.FADE)) {
                var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);
                $$$1(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
              } else {
                callbackRemove();
              }
            } else if (callback) {
              callback();
            }
          };
          _proto._adjustDialog = function _adjustDialog() {
            var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
            if (!this._isBodyOverflowing && isModalOverflowing) {
              this._element.style.paddingLeft = this._scrollbarWidth + "px";
            }
            if (this._isBodyOverflowing && !isModalOverflowing) {
              this._element.style.paddingRight = this._scrollbarWidth + "px";
            }
          };
          _proto._resetAdjustments = function _resetAdjustments() {
            this._element.style.paddingLeft = "";
            this._element.style.paddingRight = "";
          };
          _proto._checkScrollbar = function _checkScrollbar() {
            var rect = document.body.getBoundingClientRect();
            this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;
            this._scrollbarWidth = this._getScrollbarWidth();
          };
          _proto._setScrollbar = function _setScrollbar() {
            var _this9 = this;
            if (this._isBodyOverflowing) {
              $$$1(Selector.FIXED_CONTENT).each(function(index, element) {
                var actualPadding2 = $$$1(element)[0].style.paddingRight;
                var calculatedPadding2 = $$$1(element).css("padding-right");
                $$$1(element).data("padding-right", actualPadding2).css("padding-right", parseFloat(calculatedPadding2) + _this9._scrollbarWidth + "px");
              });
              $$$1(Selector.STICKY_CONTENT).each(function(index, element) {
                var actualMargin = $$$1(element)[0].style.marginRight;
                var calculatedMargin = $$$1(element).css("margin-right");
                $$$1(element).data("margin-right", actualMargin).css("margin-right", parseFloat(calculatedMargin) - _this9._scrollbarWidth + "px");
              });
              $$$1(Selector.NAVBAR_TOGGLER).each(function(index, element) {
                var actualMargin = $$$1(element)[0].style.marginRight;
                var calculatedMargin = $$$1(element).css("margin-right");
                $$$1(element).data("margin-right", actualMargin).css("margin-right", parseFloat(calculatedMargin) + _this9._scrollbarWidth + "px");
              });
              var actualPadding = document.body.style.paddingRight;
              var calculatedPadding = $$$1(document.body).css("padding-right");
              $$$1(document.body).data("padding-right", actualPadding).css("padding-right", parseFloat(calculatedPadding) + this._scrollbarWidth + "px");
            }
          };
          _proto._resetScrollbar = function _resetScrollbar() {
            $$$1(Selector.FIXED_CONTENT).each(function(index, element) {
              var padding2 = $$$1(element).data("padding-right");
              if (typeof padding2 !== "undefined") {
                $$$1(element).css("padding-right", padding2).removeData("padding-right");
              }
            });
            $$$1(Selector.STICKY_CONTENT + ", " + Selector.NAVBAR_TOGGLER).each(function(index, element) {
              var margin = $$$1(element).data("margin-right");
              if (typeof margin !== "undefined") {
                $$$1(element).css("margin-right", margin).removeData("margin-right");
              }
            });
            var padding = $$$1(document.body).data("padding-right");
            if (typeof padding !== "undefined") {
              $$$1(document.body).css("padding-right", padding).removeData("padding-right");
            }
          };
          _proto._getScrollbarWidth = function _getScrollbarWidth() {
            var scrollDiv = document.createElement("div");
            scrollDiv.className = ClassName.SCROLLBAR_MEASURER;
            document.body.appendChild(scrollDiv);
            var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
            document.body.removeChild(scrollDiv);
            return scrollbarWidth;
          };
          Modal3._jQueryInterface = function _jQueryInterface(config, relatedTarget) {
            return this.each(function() {
              var data = $$$1(this).data(DATA_KEY);
              var _config = _objectSpread({}, Default, $$$1(this).data(), typeof config === "object" && config ? config : {});
              if (!data) {
                data = new Modal3(this, _config);
                $$$1(this).data(DATA_KEY, data);
              }
              if (typeof config === "string") {
                if (typeof data[config] === "undefined") {
                  throw new TypeError('No method named "' + config + '"');
                }
                data[config](relatedTarget);
              } else if (_config.show) {
                data.show(relatedTarget);
              }
            });
          };
          _createClass(Modal3, null, [{
            key: "VERSION",
            get: function get() {
              return VERSION;
            }
          }, {
            key: "Default",
            get: function get() {
              return Default;
            }
          }]);
          return Modal3;
        }();
        $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function(event) {
          var _this10 = this;
          var target;
          var selector = Util.getSelectorFromElement(this);
          if (selector) {
            target = $$$1(selector)[0];
          }
          var config = $$$1(target).data(DATA_KEY) ? "toggle" : _objectSpread({}, $$$1(target).data(), $$$1(this).data());
          if (this.tagName === "A" || this.tagName === "AREA") {
            event.preventDefault();
          }
          var $target = $$$1(target).one(Event.SHOW, function(showEvent) {
            if (showEvent.isDefaultPrevented()) {
              return;
            }
            $target.one(Event.HIDDEN, function() {
              if ($$$1(_this10).is(":visible")) {
                _this10.focus();
              }
            });
          });
          Modal2._jQueryInterface.call($$$1(target), config, this);
        });
        $$$1.fn[NAME] = Modal2._jQueryInterface;
        $$$1.fn[NAME].Constructor = Modal2;
        $$$1.fn[NAME].noConflict = function() {
          $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
          return Modal2._jQueryInterface;
        };
        return Modal2;
      }($);
      var Tooltip = function($$$1) {
        var NAME = "tooltip";
        var VERSION = "4.1.1";
        var DATA_KEY = "bs.tooltip";
        var EVENT_KEY = "." + DATA_KEY;
        var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
        var CLASS_PREFIX = "bs-tooltip";
        var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", "g");
        var DefaultType = {
          animation: "boolean",
          template: "string",
          title: "(string|element|function)",
          trigger: "string",
          delay: "(number|object)",
          html: "boolean",
          selector: "(string|boolean)",
          placement: "(string|function)",
          offset: "(number|string)",
          container: "(string|element|boolean)",
          fallbackPlacement: "(string|array)",
          boundary: "(string|element)"
        };
        var AttachmentMap = {
          AUTO: "auto",
          TOP: "top",
          RIGHT: "right",
          BOTTOM: "bottom",
          LEFT: "left"
        };
        var Default = {
          animation: true,
          template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
          trigger: "hover focus",
          title: "",
          delay: 0,
          html: false,
          selector: false,
          placement: "top",
          offset: 0,
          container: false,
          fallbackPlacement: "flip",
          boundary: "scrollParent"
        };
        var HoverState = {
          SHOW: "show",
          OUT: "out"
        };
        var Event = {
          HIDE: "hide" + EVENT_KEY,
          HIDDEN: "hidden" + EVENT_KEY,
          SHOW: "show" + EVENT_KEY,
          SHOWN: "shown" + EVENT_KEY,
          INSERTED: "inserted" + EVENT_KEY,
          CLICK: "click" + EVENT_KEY,
          FOCUSIN: "focusin" + EVENT_KEY,
          FOCUSOUT: "focusout" + EVENT_KEY,
          MOUSEENTER: "mouseenter" + EVENT_KEY,
          MOUSELEAVE: "mouseleave" + EVENT_KEY
        };
        var ClassName = {
          FADE: "fade",
          SHOW: "show"
        };
        var Selector = {
          TOOLTIP: ".tooltip",
          TOOLTIP_INNER: ".tooltip-inner",
          ARROW: ".arrow"
        };
        var Trigger = {
          HOVER: "hover",
          FOCUS: "focus",
          CLICK: "click",
          MANUAL: "manual"
          /**
           * ------------------------------------------------------------------------
           * Class Definition
           * ------------------------------------------------------------------------
           */
        };
        var Tooltip2 = function() {
          function Tooltip3(element, config) {
            if (typeof Popper2 === "undefined") {
              throw new TypeError("Bootstrap tooltips require Popper.js (https://popper.js.org)");
            }
            this._isEnabled = true;
            this._timeout = 0;
            this._hoverState = "";
            this._activeTrigger = {};
            this._popper = null;
            this.element = element;
            this.config = this._getConfig(config);
            this.tip = null;
            this._setListeners();
          }
          var _proto = Tooltip3.prototype;
          _proto.enable = function enable() {
            this._isEnabled = true;
          };
          _proto.disable = function disable() {
            this._isEnabled = false;
          };
          _proto.toggleEnabled = function toggleEnabled() {
            this._isEnabled = !this._isEnabled;
          };
          _proto.toggle = function toggle(event) {
            if (!this._isEnabled) {
              return;
            }
            if (event) {
              var dataKey = this.constructor.DATA_KEY;
              var context = $$$1(event.currentTarget).data(dataKey);
              if (!context) {
                context = new this.constructor(event.currentTarget, this._getDelegateConfig());
                $$$1(event.currentTarget).data(dataKey, context);
              }
              context._activeTrigger.click = !context._activeTrigger.click;
              if (context._isWithActiveTrigger()) {
                context._enter(null, context);
              } else {
                context._leave(null, context);
              }
            } else {
              if ($$$1(this.getTipElement()).hasClass(ClassName.SHOW)) {
                this._leave(null, this);
                return;
              }
              this._enter(null, this);
            }
          };
          _proto.dispose = function dispose() {
            clearTimeout(this._timeout);
            $$$1.removeData(this.element, this.constructor.DATA_KEY);
            $$$1(this.element).off(this.constructor.EVENT_KEY);
            $$$1(this.element).closest(".modal").off("hide.bs.modal");
            if (this.tip) {
              $$$1(this.tip).remove();
            }
            this._isEnabled = null;
            this._timeout = null;
            this._hoverState = null;
            this._activeTrigger = null;
            if (this._popper !== null) {
              this._popper.destroy();
            }
            this._popper = null;
            this.element = null;
            this.config = null;
            this.tip = null;
          };
          _proto.show = function show() {
            var _this = this;
            if ($$$1(this.element).css("display") === "none") {
              throw new Error("Please use show on visible elements");
            }
            var showEvent = $$$1.Event(this.constructor.Event.SHOW);
            if (this.isWithContent() && this._isEnabled) {
              $$$1(this.element).trigger(showEvent);
              var isInTheDom = $$$1.contains(this.element.ownerDocument.documentElement, this.element);
              if (showEvent.isDefaultPrevented() || !isInTheDom) {
                return;
              }
              var tip = this.getTipElement();
              var tipId = Util.getUID(this.constructor.NAME);
              tip.setAttribute("id", tipId);
              this.element.setAttribute("aria-describedby", tipId);
              this.setContent();
              if (this.config.animation) {
                $$$1(tip).addClass(ClassName.FADE);
              }
              var placement = typeof this.config.placement === "function" ? this.config.placement.call(this, tip, this.element) : this.config.placement;
              var attachment = this._getAttachment(placement);
              this.addAttachmentClass(attachment);
              var container = this.config.container === false ? document.body : $$$1(this.config.container);
              $$$1(tip).data(this.constructor.DATA_KEY, this);
              if (!$$$1.contains(this.element.ownerDocument.documentElement, this.tip)) {
                $$$1(tip).appendTo(container);
              }
              $$$1(this.element).trigger(this.constructor.Event.INSERTED);
              this._popper = new Popper2(this.element, tip, {
                placement: attachment,
                modifiers: {
                  offset: {
                    offset: this.config.offset
                  },
                  flip: {
                    behavior: this.config.fallbackPlacement
                  },
                  arrow: {
                    element: Selector.ARROW
                  },
                  preventOverflow: {
                    boundariesElement: this.config.boundary
                  }
                },
                onCreate: function onCreate2(data) {
                  if (data.originalPlacement !== data.placement) {
                    _this._handlePopperPlacementChange(data);
                  }
                },
                onUpdate: function onUpdate2(data) {
                  _this._handlePopperPlacementChange(data);
                }
              });
              $$$1(tip).addClass(ClassName.SHOW);
              if ("ontouchstart" in document.documentElement) {
                $$$1(document.body).children().on("mouseover", null, $$$1.noop);
              }
              var complete = function complete2() {
                if (_this.config.animation) {
                  _this._fixTransition();
                }
                var prevHoverState = _this._hoverState;
                _this._hoverState = null;
                $$$1(_this.element).trigger(_this.constructor.Event.SHOWN);
                if (prevHoverState === HoverState.OUT) {
                  _this._leave(null, _this);
                }
              };
              if ($$$1(this.tip).hasClass(ClassName.FADE)) {
                var transitionDuration = Util.getTransitionDurationFromElement(this.tip);
                $$$1(this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
              } else {
                complete();
              }
            }
          };
          _proto.hide = function hide2(callback) {
            var _this2 = this;
            var tip = this.getTipElement();
            var hideEvent = $$$1.Event(this.constructor.Event.HIDE);
            var complete = function complete2() {
              if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
                tip.parentNode.removeChild(tip);
              }
              _this2._cleanTipClass();
              _this2.element.removeAttribute("aria-describedby");
              $$$1(_this2.element).trigger(_this2.constructor.Event.HIDDEN);
              if (_this2._popper !== null) {
                _this2._popper.destroy();
              }
              if (callback) {
                callback();
              }
            };
            $$$1(this.element).trigger(hideEvent);
            if (hideEvent.isDefaultPrevented()) {
              return;
            }
            $$$1(tip).removeClass(ClassName.SHOW);
            if ("ontouchstart" in document.documentElement) {
              $$$1(document.body).children().off("mouseover", null, $$$1.noop);
            }
            this._activeTrigger[Trigger.CLICK] = false;
            this._activeTrigger[Trigger.FOCUS] = false;
            this._activeTrigger[Trigger.HOVER] = false;
            if ($$$1(this.tip).hasClass(ClassName.FADE)) {
              var transitionDuration = Util.getTransitionDurationFromElement(tip);
              $$$1(tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
            } else {
              complete();
            }
            this._hoverState = "";
          };
          _proto.update = function update2() {
            if (this._popper !== null) {
              this._popper.scheduleUpdate();
            }
          };
          _proto.isWithContent = function isWithContent() {
            return Boolean(this.getTitle());
          };
          _proto.addAttachmentClass = function addAttachmentClass(attachment) {
            $$$1(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
          };
          _proto.getTipElement = function getTipElement() {
            this.tip = this.tip || $$$1(this.config.template)[0];
            return this.tip;
          };
          _proto.setContent = function setContent() {
            var $tip = $$$1(this.getTipElement());
            this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
            $tip.removeClass(ClassName.FADE + " " + ClassName.SHOW);
          };
          _proto.setElementContent = function setElementContent($element, content) {
            var html = this.config.html;
            if (typeof content === "object" && (content.nodeType || content.jquery)) {
              if (html) {
                if (!$$$1(content).parent().is($element)) {
                  $element.empty().append(content);
                }
              } else {
                $element.text($$$1(content).text());
              }
            } else {
              $element[html ? "html" : "text"](content);
            }
          };
          _proto.getTitle = function getTitle() {
            var title = this.element.getAttribute("data-original-title");
            if (!title) {
              title = typeof this.config.title === "function" ? this.config.title.call(this.element) : this.config.title;
            }
            return title;
          };
          _proto._getAttachment = function _getAttachment(placement) {
            return AttachmentMap[placement.toUpperCase()];
          };
          _proto._setListeners = function _setListeners() {
            var _this3 = this;
            var triggers = this.config.trigger.split(" ");
            triggers.forEach(function(trigger) {
              if (trigger === "click") {
                $$$1(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function(event) {
                  return _this3.toggle(event);
                });
              } else if (trigger !== Trigger.MANUAL) {
                var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
                var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;
                $$$1(_this3.element).on(eventIn, _this3.config.selector, function(event) {
                  return _this3._enter(event);
                }).on(eventOut, _this3.config.selector, function(event) {
                  return _this3._leave(event);
                });
              }
              $$$1(_this3.element).closest(".modal").on("hide.bs.modal", function() {
                return _this3.hide();
              });
            });
            if (this.config.selector) {
              this.config = _objectSpread({}, this.config, {
                trigger: "manual",
                selector: ""
              });
            } else {
              this._fixTitle();
            }
          };
          _proto._fixTitle = function _fixTitle() {
            var titleType = typeof this.element.getAttribute("data-original-title");
            if (this.element.getAttribute("title") || titleType !== "string") {
              this.element.setAttribute("data-original-title", this.element.getAttribute("title") || "");
              this.element.setAttribute("title", "");
            }
          };
          _proto._enter = function _enter(event, context) {
            var dataKey = this.constructor.DATA_KEY;
            context = context || $$$1(event.currentTarget).data(dataKey);
            if (!context) {
              context = new this.constructor(event.currentTarget, this._getDelegateConfig());
              $$$1(event.currentTarget).data(dataKey, context);
            }
            if (event) {
              context._activeTrigger[event.type === "focusin" ? Trigger.FOCUS : Trigger.HOVER] = true;
            }
            if ($$$1(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
              context._hoverState = HoverState.SHOW;
              return;
            }
            clearTimeout(context._timeout);
            context._hoverState = HoverState.SHOW;
            if (!context.config.delay || !context.config.delay.show) {
              context.show();
              return;
            }
            context._timeout = setTimeout(function() {
              if (context._hoverState === HoverState.SHOW) {
                context.show();
              }
            }, context.config.delay.show);
          };
          _proto._leave = function _leave(event, context) {
            var dataKey = this.constructor.DATA_KEY;
            context = context || $$$1(event.currentTarget).data(dataKey);
            if (!context) {
              context = new this.constructor(event.currentTarget, this._getDelegateConfig());
              $$$1(event.currentTarget).data(dataKey, context);
            }
            if (event) {
              context._activeTrigger[event.type === "focusout" ? Trigger.FOCUS : Trigger.HOVER] = false;
            }
            if (context._isWithActiveTrigger()) {
              return;
            }
            clearTimeout(context._timeout);
            context._hoverState = HoverState.OUT;
            if (!context.config.delay || !context.config.delay.hide) {
              context.hide();
              return;
            }
            context._timeout = setTimeout(function() {
              if (context._hoverState === HoverState.OUT) {
                context.hide();
              }
            }, context.config.delay.hide);
          };
          _proto._isWithActiveTrigger = function _isWithActiveTrigger() {
            for (var trigger in this._activeTrigger) {
              if (this._activeTrigger[trigger]) {
                return true;
              }
            }
            return false;
          };
          _proto._getConfig = function _getConfig(config) {
            config = _objectSpread({}, this.constructor.Default, $$$1(this.element).data(), typeof config === "object" && config ? config : {});
            if (typeof config.delay === "number") {
              config.delay = {
                show: config.delay,
                hide: config.delay
              };
            }
            if (typeof config.title === "number") {
              config.title = config.title.toString();
            }
            if (typeof config.content === "number") {
              config.content = config.content.toString();
            }
            Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);
            return config;
          };
          _proto._getDelegateConfig = function _getDelegateConfig() {
            var config = {};
            if (this.config) {
              for (var key in this.config) {
                if (this.constructor.Default[key] !== this.config[key]) {
                  config[key] = this.config[key];
                }
              }
            }
            return config;
          };
          _proto._cleanTipClass = function _cleanTipClass() {
            var $tip = $$$1(this.getTipElement());
            var tabClass = $tip.attr("class").match(BSCLS_PREFIX_REGEX);
            if (tabClass !== null && tabClass.length > 0) {
              $tip.removeClass(tabClass.join(""));
            }
          };
          _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(data) {
            this._cleanTipClass();
            this.addAttachmentClass(this._getAttachment(data.placement));
          };
          _proto._fixTransition = function _fixTransition() {
            var tip = this.getTipElement();
            var initConfigAnimation = this.config.animation;
            if (tip.getAttribute("x-placement") !== null) {
              return;
            }
            $$$1(tip).removeClass(ClassName.FADE);
            this.config.animation = false;
            this.hide();
            this.show();
            this.config.animation = initConfigAnimation;
          };
          Tooltip3._jQueryInterface = function _jQueryInterface(config) {
            return this.each(function() {
              var data = $$$1(this).data(DATA_KEY);
              var _config = typeof config === "object" && config;
              if (!data && /dispose|hide/.test(config)) {
                return;
              }
              if (!data) {
                data = new Tooltip3(this, _config);
                $$$1(this).data(DATA_KEY, data);
              }
              if (typeof config === "string") {
                if (typeof data[config] === "undefined") {
                  throw new TypeError('No method named "' + config + '"');
                }
                data[config]();
              }
            });
          };
          _createClass(Tooltip3, null, [{
            key: "VERSION",
            get: function get() {
              return VERSION;
            }
          }, {
            key: "Default",
            get: function get() {
              return Default;
            }
          }, {
            key: "NAME",
            get: function get() {
              return NAME;
            }
          }, {
            key: "DATA_KEY",
            get: function get() {
              return DATA_KEY;
            }
          }, {
            key: "Event",
            get: function get() {
              return Event;
            }
          }, {
            key: "EVENT_KEY",
            get: function get() {
              return EVENT_KEY;
            }
          }, {
            key: "DefaultType",
            get: function get() {
              return DefaultType;
            }
          }]);
          return Tooltip3;
        }();
        $$$1.fn[NAME] = Tooltip2._jQueryInterface;
        $$$1.fn[NAME].Constructor = Tooltip2;
        $$$1.fn[NAME].noConflict = function() {
          $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
          return Tooltip2._jQueryInterface;
        };
        return Tooltip2;
      }($, Popper2);
      var Popover = function($$$1) {
        var NAME = "popover";
        var VERSION = "4.1.1";
        var DATA_KEY = "bs.popover";
        var EVENT_KEY = "." + DATA_KEY;
        var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
        var CLASS_PREFIX = "bs-popover";
        var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)" + CLASS_PREFIX + "\\S+", "g");
        var Default = _objectSpread({}, Tooltip.Default, {
          placement: "right",
          trigger: "click",
          content: "",
          template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
        });
        var DefaultType = _objectSpread({}, Tooltip.DefaultType, {
          content: "(string|element|function)"
        });
        var ClassName = {
          FADE: "fade",
          SHOW: "show"
        };
        var Selector = {
          TITLE: ".popover-header",
          CONTENT: ".popover-body"
        };
        var Event = {
          HIDE: "hide" + EVENT_KEY,
          HIDDEN: "hidden" + EVENT_KEY,
          SHOW: "show" + EVENT_KEY,
          SHOWN: "shown" + EVENT_KEY,
          INSERTED: "inserted" + EVENT_KEY,
          CLICK: "click" + EVENT_KEY,
          FOCUSIN: "focusin" + EVENT_KEY,
          FOCUSOUT: "focusout" + EVENT_KEY,
          MOUSEENTER: "mouseenter" + EVENT_KEY,
          MOUSELEAVE: "mouseleave" + EVENT_KEY
          /**
           * ------------------------------------------------------------------------
           * Class Definition
           * ------------------------------------------------------------------------
           */
        };
        var Popover2 = function(_Tooltip) {
          _inheritsLoose(Popover3, _Tooltip);
          function Popover3() {
            return _Tooltip.apply(this, arguments) || this;
          }
          var _proto = Popover3.prototype;
          _proto.isWithContent = function isWithContent() {
            return this.getTitle() || this._getContent();
          };
          _proto.addAttachmentClass = function addAttachmentClass(attachment) {
            $$$1(this.getTipElement()).addClass(CLASS_PREFIX + "-" + attachment);
          };
          _proto.getTipElement = function getTipElement() {
            this.tip = this.tip || $$$1(this.config.template)[0];
            return this.tip;
          };
          _proto.setContent = function setContent() {
            var $tip = $$$1(this.getTipElement());
            this.setElementContent($tip.find(Selector.TITLE), this.getTitle());
            var content = this._getContent();
            if (typeof content === "function") {
              content = content.call(this.element);
            }
            this.setElementContent($tip.find(Selector.CONTENT), content);
            $tip.removeClass(ClassName.FADE + " " + ClassName.SHOW);
          };
          _proto._getContent = function _getContent() {
            return this.element.getAttribute("data-content") || this.config.content;
          };
          _proto._cleanTipClass = function _cleanTipClass() {
            var $tip = $$$1(this.getTipElement());
            var tabClass = $tip.attr("class").match(BSCLS_PREFIX_REGEX);
            if (tabClass !== null && tabClass.length > 0) {
              $tip.removeClass(tabClass.join(""));
            }
          };
          Popover3._jQueryInterface = function _jQueryInterface(config) {
            return this.each(function() {
              var data = $$$1(this).data(DATA_KEY);
              var _config = typeof config === "object" ? config : null;
              if (!data && /destroy|hide/.test(config)) {
                return;
              }
              if (!data) {
                data = new Popover3(this, _config);
                $$$1(this).data(DATA_KEY, data);
              }
              if (typeof config === "string") {
                if (typeof data[config] === "undefined") {
                  throw new TypeError('No method named "' + config + '"');
                }
                data[config]();
              }
            });
          };
          _createClass(Popover3, null, [{
            key: "VERSION",
            // Getters
            get: function get() {
              return VERSION;
            }
          }, {
            key: "Default",
            get: function get() {
              return Default;
            }
          }, {
            key: "NAME",
            get: function get() {
              return NAME;
            }
          }, {
            key: "DATA_KEY",
            get: function get() {
              return DATA_KEY;
            }
          }, {
            key: "Event",
            get: function get() {
              return Event;
            }
          }, {
            key: "EVENT_KEY",
            get: function get() {
              return EVENT_KEY;
            }
          }, {
            key: "DefaultType",
            get: function get() {
              return DefaultType;
            }
          }]);
          return Popover3;
        }(Tooltip);
        $$$1.fn[NAME] = Popover2._jQueryInterface;
        $$$1.fn[NAME].Constructor = Popover2;
        $$$1.fn[NAME].noConflict = function() {
          $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
          return Popover2._jQueryInterface;
        };
        return Popover2;
      }($);
      var ScrollSpy = function($$$1) {
        var NAME = "scrollspy";
        var VERSION = "4.1.1";
        var DATA_KEY = "bs.scrollspy";
        var EVENT_KEY = "." + DATA_KEY;
        var DATA_API_KEY = ".data-api";
        var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
        var Default = {
          offset: 10,
          method: "auto",
          target: ""
        };
        var DefaultType = {
          offset: "number",
          method: "string",
          target: "(string|element)"
        };
        var Event = {
          ACTIVATE: "activate" + EVENT_KEY,
          SCROLL: "scroll" + EVENT_KEY,
          LOAD_DATA_API: "load" + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
          DROPDOWN_ITEM: "dropdown-item",
          DROPDOWN_MENU: "dropdown-menu",
          ACTIVE: "active"
        };
        var Selector = {
          DATA_SPY: '[data-spy="scroll"]',
          ACTIVE: ".active",
          NAV_LIST_GROUP: ".nav, .list-group",
          NAV_LINKS: ".nav-link",
          NAV_ITEMS: ".nav-item",
          LIST_ITEMS: ".list-group-item",
          DROPDOWN: ".dropdown",
          DROPDOWN_ITEMS: ".dropdown-item",
          DROPDOWN_TOGGLE: ".dropdown-toggle"
        };
        var OffsetMethod = {
          OFFSET: "offset",
          POSITION: "position"
          /**
           * ------------------------------------------------------------------------
           * Class Definition
           * ------------------------------------------------------------------------
           */
        };
        var ScrollSpy2 = function() {
          function ScrollSpy3(element, config) {
            var _this = this;
            this._element = element;
            this._scrollElement = element.tagName === "BODY" ? window : element;
            this._config = this._getConfig(config);
            this._selector = this._config.target + " " + Selector.NAV_LINKS + "," + (this._config.target + " " + Selector.LIST_ITEMS + ",") + (this._config.target + " " + Selector.DROPDOWN_ITEMS);
            this._offsets = [];
            this._targets = [];
            this._activeTarget = null;
            this._scrollHeight = 0;
            $$$1(this._scrollElement).on(Event.SCROLL, function(event) {
              return _this._process(event);
            });
            this.refresh();
            this._process();
          }
          var _proto = ScrollSpy3.prototype;
          _proto.refresh = function refresh() {
            var _this2 = this;
            var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;
            var offsetMethod = this._config.method === "auto" ? autoMethod : this._config.method;
            var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;
            this._offsets = [];
            this._targets = [];
            this._scrollHeight = this._getScrollHeight();
            var targets = $$$1.makeArray($$$1(this._selector));
            targets.map(function(element) {
              var target;
              var targetSelector = Util.getSelectorFromElement(element);
              if (targetSelector) {
                target = $$$1(targetSelector)[0];
              }
              if (target) {
                var targetBCR = target.getBoundingClientRect();
                if (targetBCR.width || targetBCR.height) {
                  return [$$$1(target)[offsetMethod]().top + offsetBase, targetSelector];
                }
              }
              return null;
            }).filter(function(item) {
              return item;
            }).sort(function(a, b) {
              return a[0] - b[0];
            }).forEach(function(item) {
              _this2._offsets.push(item[0]);
              _this2._targets.push(item[1]);
            });
          };
          _proto.dispose = function dispose() {
            $$$1.removeData(this._element, DATA_KEY);
            $$$1(this._scrollElement).off(EVENT_KEY);
            this._element = null;
            this._scrollElement = null;
            this._config = null;
            this._selector = null;
            this._offsets = null;
            this._targets = null;
            this._activeTarget = null;
            this._scrollHeight = null;
          };
          _proto._getConfig = function _getConfig(config) {
            config = _objectSpread({}, Default, typeof config === "object" && config ? config : {});
            if (typeof config.target !== "string") {
              var id = $$$1(config.target).attr("id");
              if (!id) {
                id = Util.getUID(NAME);
                $$$1(config.target).attr("id", id);
              }
              config.target = "#" + id;
            }
            Util.typeCheckConfig(NAME, config, DefaultType);
            return config;
          };
          _proto._getScrollTop = function _getScrollTop() {
            return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
          };
          _proto._getScrollHeight = function _getScrollHeight() {
            return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
          };
          _proto._getOffsetHeight = function _getOffsetHeight() {
            return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
          };
          _proto._process = function _process() {
            var scrollTop = this._getScrollTop() + this._config.offset;
            var scrollHeight = this._getScrollHeight();
            var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();
            if (this._scrollHeight !== scrollHeight) {
              this.refresh();
            }
            if (scrollTop >= maxScroll) {
              var target = this._targets[this._targets.length - 1];
              if (this._activeTarget !== target) {
                this._activate(target);
              }
              return;
            }
            if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
              this._activeTarget = null;
              this._clear();
              return;
            }
            for (var i = this._offsets.length; i--; ) {
              var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === "undefined" || scrollTop < this._offsets[i + 1]);
              if (isActiveTarget) {
                this._activate(this._targets[i]);
              }
            }
          };
          _proto._activate = function _activate(target) {
            this._activeTarget = target;
            this._clear();
            var queries = this._selector.split(",");
            queries = queries.map(function(selector) {
              return selector + '[data-target="' + target + '"],' + (selector + '[href="' + target + '"]');
            });
            var $link = $$$1(queries.join(","));
            if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {
              $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
              $link.addClass(ClassName.ACTIVE);
            } else {
              $link.addClass(ClassName.ACTIVE);
              $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + ", " + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE);
              $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);
            }
            $$$1(this._scrollElement).trigger(Event.ACTIVATE, {
              relatedTarget: target
            });
          };
          _proto._clear = function _clear() {
            $$$1(this._selector).filter(Selector.ACTIVE).removeClass(ClassName.ACTIVE);
          };
          ScrollSpy3._jQueryInterface = function _jQueryInterface(config) {
            return this.each(function() {
              var data = $$$1(this).data(DATA_KEY);
              var _config = typeof config === "object" && config;
              if (!data) {
                data = new ScrollSpy3(this, _config);
                $$$1(this).data(DATA_KEY, data);
              }
              if (typeof config === "string") {
                if (typeof data[config] === "undefined") {
                  throw new TypeError('No method named "' + config + '"');
                }
                data[config]();
              }
            });
          };
          _createClass(ScrollSpy3, null, [{
            key: "VERSION",
            get: function get() {
              return VERSION;
            }
          }, {
            key: "Default",
            get: function get() {
              return Default;
            }
          }]);
          return ScrollSpy3;
        }();
        $$$1(window).on(Event.LOAD_DATA_API, function() {
          var scrollSpys = $$$1.makeArray($$$1(Selector.DATA_SPY));
          for (var i = scrollSpys.length; i--; ) {
            var $spy = $$$1(scrollSpys[i]);
            ScrollSpy2._jQueryInterface.call($spy, $spy.data());
          }
        });
        $$$1.fn[NAME] = ScrollSpy2._jQueryInterface;
        $$$1.fn[NAME].Constructor = ScrollSpy2;
        $$$1.fn[NAME].noConflict = function() {
          $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
          return ScrollSpy2._jQueryInterface;
        };
        return ScrollSpy2;
      }($);
      var Tab = function($$$1) {
        var NAME = "tab";
        var VERSION = "4.1.1";
        var DATA_KEY = "bs.tab";
        var EVENT_KEY = "." + DATA_KEY;
        var DATA_API_KEY = ".data-api";
        var JQUERY_NO_CONFLICT = $$$1.fn[NAME];
        var Event = {
          HIDE: "hide" + EVENT_KEY,
          HIDDEN: "hidden" + EVENT_KEY,
          SHOW: "show" + EVENT_KEY,
          SHOWN: "shown" + EVENT_KEY,
          CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY
        };
        var ClassName = {
          DROPDOWN_MENU: "dropdown-menu",
          ACTIVE: "active",
          DISABLED: "disabled",
          FADE: "fade",
          SHOW: "show"
        };
        var Selector = {
          DROPDOWN: ".dropdown",
          NAV_LIST_GROUP: ".nav, .list-group",
          ACTIVE: ".active",
          ACTIVE_UL: "> li > .active",
          DATA_TOGGLE: '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',
          DROPDOWN_TOGGLE: ".dropdown-toggle",
          DROPDOWN_ACTIVE_CHILD: "> .dropdown-menu .active"
          /**
           * ------------------------------------------------------------------------
           * Class Definition
           * ------------------------------------------------------------------------
           */
        };
        var Tab2 = function() {
          function Tab3(element) {
            this._element = element;
          }
          var _proto = Tab3.prototype;
          _proto.show = function show() {
            var _this = this;
            if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $$$1(this._element).hasClass(ClassName.ACTIVE) || $$$1(this._element).hasClass(ClassName.DISABLED)) {
              return;
            }
            var target;
            var previous;
            var listElement = $$$1(this._element).closest(Selector.NAV_LIST_GROUP)[0];
            var selector = Util.getSelectorFromElement(this._element);
            if (listElement) {
              var itemSelector = listElement.nodeName === "UL" ? Selector.ACTIVE_UL : Selector.ACTIVE;
              previous = $$$1.makeArray($$$1(listElement).find(itemSelector));
              previous = previous[previous.length - 1];
            }
            var hideEvent = $$$1.Event(Event.HIDE, {
              relatedTarget: this._element
            });
            var showEvent = $$$1.Event(Event.SHOW, {
              relatedTarget: previous
            });
            if (previous) {
              $$$1(previous).trigger(hideEvent);
            }
            $$$1(this._element).trigger(showEvent);
            if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
              return;
            }
            if (selector) {
              target = $$$1(selector)[0];
            }
            this._activate(this._element, listElement);
            var complete = function complete2() {
              var hiddenEvent = $$$1.Event(Event.HIDDEN, {
                relatedTarget: _this._element
              });
              var shownEvent = $$$1.Event(Event.SHOWN, {
                relatedTarget: previous
              });
              $$$1(previous).trigger(hiddenEvent);
              $$$1(_this._element).trigger(shownEvent);
            };
            if (target) {
              this._activate(target, target.parentNode, complete);
            } else {
              complete();
            }
          };
          _proto.dispose = function dispose() {
            $$$1.removeData(this._element, DATA_KEY);
            this._element = null;
          };
          _proto._activate = function _activate(element, container, callback) {
            var _this2 = this;
            var activeElements;
            if (container.nodeName === "UL") {
              activeElements = $$$1(container).find(Selector.ACTIVE_UL);
            } else {
              activeElements = $$$1(container).children(Selector.ACTIVE);
            }
            var active = activeElements[0];
            var isTransitioning = callback && active && $$$1(active).hasClass(ClassName.FADE);
            var complete = function complete2() {
              return _this2._transitionComplete(element, active, callback);
            };
            if (active && isTransitioning) {
              var transitionDuration = Util.getTransitionDurationFromElement(active);
              $$$1(active).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
            } else {
              complete();
            }
          };
          _proto._transitionComplete = function _transitionComplete(element, active, callback) {
            if (active) {
              $$$1(active).removeClass(ClassName.SHOW + " " + ClassName.ACTIVE);
              var dropdownChild = $$$1(active.parentNode).find(Selector.DROPDOWN_ACTIVE_CHILD)[0];
              if (dropdownChild) {
                $$$1(dropdownChild).removeClass(ClassName.ACTIVE);
              }
              if (active.getAttribute("role") === "tab") {
                active.setAttribute("aria-selected", false);
              }
            }
            $$$1(element).addClass(ClassName.ACTIVE);
            if (element.getAttribute("role") === "tab") {
              element.setAttribute("aria-selected", true);
            }
            Util.reflow(element);
            $$$1(element).addClass(ClassName.SHOW);
            if (element.parentNode && $$$1(element.parentNode).hasClass(ClassName.DROPDOWN_MENU)) {
              var dropdownElement = $$$1(element).closest(Selector.DROPDOWN)[0];
              if (dropdownElement) {
                $$$1(dropdownElement).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);
              }
              element.setAttribute("aria-expanded", true);
            }
            if (callback) {
              callback();
            }
          };
          Tab3._jQueryInterface = function _jQueryInterface(config) {
            return this.each(function() {
              var $this = $$$1(this);
              var data = $this.data(DATA_KEY);
              if (!data) {
                data = new Tab3(this);
                $this.data(DATA_KEY, data);
              }
              if (typeof config === "string") {
                if (typeof data[config] === "undefined") {
                  throw new TypeError('No method named "' + config + '"');
                }
                data[config]();
              }
            });
          };
          _createClass(Tab3, null, [{
            key: "VERSION",
            get: function get() {
              return VERSION;
            }
          }]);
          return Tab3;
        }();
        $$$1(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function(event) {
          event.preventDefault();
          Tab2._jQueryInterface.call($$$1(this), "show");
        });
        $$$1.fn[NAME] = Tab2._jQueryInterface;
        $$$1.fn[NAME].Constructor = Tab2;
        $$$1.fn[NAME].noConflict = function() {
          $$$1.fn[NAME] = JQUERY_NO_CONFLICT;
          return Tab2._jQueryInterface;
        };
        return Tab2;
      }($);
      (function($$$1) {
        if (typeof $$$1 === "undefined") {
          throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
        }
        var version = $$$1.fn.jquery.split(" ")[0].split(".");
        var minMajor = 1;
        var ltMajor = 2;
        var minMinor = 9;
        var minPatch = 1;
        var maxMajor = 4;
        if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
          throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0");
        }
      })($);
      exports2.Util = Util;
      exports2.Alert = Alert;
      exports2.Button = Button;
      exports2.Carousel = Carousel;
      exports2.Collapse = Collapse;
      exports2.Dropdown = Dropdown;
      exports2.Modal = Modal;
      exports2.Popover = Popover;
      exports2.Scrollspy = ScrollSpy;
      exports2.Tab = Tab;
      exports2.Tooltip = Tooltip;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});
export default require_bootstrap();
/*! Bundled license information:

popper.js/dist/esm/popper.js:
  (**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.16.1
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *)

bootstrap/dist/js/bootstrap.js:
  (*!
    * Bootstrap v4.1.1 (https://getbootstrap.com/)
    * Copyright 2011-2018 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
    *)
*/
//# sourceMappingURL=bootstrap.js.map
